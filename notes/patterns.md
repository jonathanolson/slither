
# Patterns

- TODO
  - 
  - Generate:
    - HEY HEY -- highlander can be added like "only"? 
    - Current:
      - getOnlyImpliedSectorHexBoardRules 1 0 [kitty 0] <--- crashed, last one
      - getImpliedSectorGeneralBoardRules 1 2 [kitty 1] <--- crashed, last one
      - getImpliedColorHexBoardRules 1 0 [kitty 2] <--- #132, but OMG it is chugging!!!
      - getHighlanderOnlyImpliedSquareBoardRules 2 0 [kitty 3]
      - getHighlanderOnlyImpliedSquareBoardRules 2 1 [kitty 4]
      - getHighlanderOnlyImpliedSquareBoardRules 2 2 [kitty 5]
      - getHighlanderOnlyImpliedSquareBoardRules 2 3 [kitty 6]
      - getHighlanderOnlyImpliedSquareBoardRules 2 4 [kitty 7]
      - 
      - Failure on node bin/generate.js getHighlanderImpliedGeneralBoardRules 0 2 --- error?
      - Failure on node bin/generate.js getHighlanderImpliedSectorGeneralBoardRules 0 2 --- error?
      - 
      - Missing:
        - getImpliedGeneralBoardRules 2 47,48 (MEMORY FAILURES minisat) 
        - getOnlyImpliedSquareBoardRules 4 9 <--- crash on complete? is it in console history? Try on browser direct macOS?
      - 
      - getImpliedColorGeneralBoardRules 1 2 [PC #132 - eeek] -- last of its type
      - getImpliedGeneralBoardRules 2 7 [PC + #46 ek + restart]
      - getImpliedGeneralBoardRules 2 46 [PC] <--- hahah OMG 101415 solutions(!) (at least minisat didn't die)
      - getImpliedGeneralBoardRules 2 52 [PC]
      - getImpliedGeneralBoardRules 2 54 [PC]
      - getOnlyImpliedSquareBoardRules 4 15 [PC]
      - getOnlyImpliedSquareBoardRules 4 16 [PC] (goes to 4,75)
      - getOnlyImpliedSquareBoardRules 4 17 [PC]
      - getOnlyImpliedSquareBoardRules 4 18 [PC]
      - getOnlyImpliedSquareBoardRules 4 19 [PC]
      - getOnlyImpliedSquareBoardRules 4 20 [PC]
      - getOnlyImpliedSquareBoardRules 4 21 [PC]
      - getOnlyImpliedSquareBoardRules 4 22 [PC]
    - Future:
      - Highlander on smaller boards(!)
  - 
  - DO THE LOCALE STUFF, and then... sneak and phet-lib TS so we don't keep having all of the chunk issues? hopefully?
  - 
  - PRIORITIZE "all" before curating rules (since that is likely to affect things)
  - 
  - CURATED RULES
    - Should we create ONE curated list, and then SCAN 
  - 
  - HEY create "generations" that include BASIC boards(!)
  - 
  - PatternRule should have input, output, but also MINIMAL_MATCH_INPUT?
  - 
  - Show embeddings, so we can do rule stuff?
  - 
  - Database of rules:
    - NAME the ruleset BY ITS PATTERN BOARD NAME?
      - (do basic boards have good names? we need that)
    - [HOW TO LOOK UP POTENTIAL RULES - have a rule database?]
      - Could we... rely on AJAX to load rules?
  - 
  - HOW TO REGENERATE RULES THAT INVOLVE TRIANGLES... omg (we had a loop fix)
  - 
  - Highlander + color:
    - Essentially a "red exit edge" is where the color is forced to be the same for the entire exit
    - This seems "solvable" in the "ALL" solving stage?
  - 
  - Highlander potential solving changes:
    - (a) don't precompute closures, do it on demand (I mean, from persisted RichSolutions...)
    - (b) precompute more efficiently (recursively)
      - Can just "combine" bins as we recurse
      - "no solutions possible" will recurse trivially
    - Solutions with different vertex connections are NEVER in the same bin
      - Corollary: Solutions with a black exit edge are NEVER in the same bin as a hard-red or soft-red-or-double-black
      - Corollary: Adding a red exit edge as a feature will ONLY (a) filter out bins with black exit edges, and (b) combine bins with hard-red and soft-red-or-double-black exits
        - IMPORTANT: It will never INVALIDATE only part of a bin.
    - [OOO] - If none of the potential solutions has vertex connection overlap, we gain no information from highlander (and could skip)
  - 
  - Run a ton of "completed puzzle testing" for RANDOM puzzles. --- HEY get this working with a PatternSolver(?)
    - Ensure that highlander and other rules are ALWAYS correct within these! (VERY MUCH HIGHLANDER)
  - 
  - [future] - we can solve based on vertex connection info, could this be a feature/constraint in the future?
    - Constraint!!!
  - 
  - rule.html
    - Could just take an input pattern
  - 
  - Build failure, trying `npm run build --max-old-space-size`
    - export NODE_OPTIONS=--max-old-space-size=32768
    - Maybe we should... ditch loading all the data? (remove references for the collections tests?)
  - 
  - MINISAT FAILURE
    - getImpliedGeneralBoardRules 2 47 [PC] <<<<------- WAIT WAIT we have.... minisat FAILULRE
    - 2 48 also
    - minisat-OUT
    - Perhaps we are giving it too many loops?
    - CONSIDER:
      - What if we... manually compute these? For these SMALL cases, it is probably practical
  - 
  - [LinCb0!!!] General performance enhancements:
    - [First, testing infrastructure] ADD IN TESTING TO ENSURE GENERATION IS STABLE!!!
      - Then have a way to UNIT TEST to see if our rule generations are EQUAL to what is there.
    - See pruning discussion with ChatGPT
      - [implement LinCb0] - from https://arxiv.org/pdf/2011.04928, etc.
        - Looks important for e.g. getImpliedColorSquareBoardRules 2 4, which is going up to 47k implications 
      - [implement pruning] from the paper
      - We can see if implications would be VIOLATED by adding an attribute (early termination)
      - OMG OMG - treat implications maybe differently if they "imply everything" (invalid)
        - Still keep those in our implications,
        - Consider showing how many non-to-invalid implications we have in our set (in our debugging info)
    - Performance test best way to handle bit vectors - 110 bits seems slow?
    - CONSIDER reordering of attributes or objects!!!!
      - [NO] START WITH OBJECTS WITH SMALLER INTENTS, OR ONES THAT INTERSECT WITH MANY OTHER OBJECTS INTENTS
        - Wait, what would this do...?
      - [probably not - only after adding pruning] REORDER ATTRIBUTES?
  -
  - Image output robustness: if a ruleset has more than N rules, split it up into chunks!
  - 
  - FIX NAMING eventually, 'general-implied' should be 'general-edge-implied'?
  - 
  - "all" feature set - how to check to see if faces IMPLY edges, and vice versa?
  - 
  - Check if implied is using isCanonicalWith (we might want to only use canonical rules, should be guaranteed to have them, no?)
    - Maybe not?
  - 
  - [meh, we don't have huge amounts of implications] HEY! getEmbeddedRules might be giving us some "duplicates". I think we were filtering these out before
    - Filter these out where possible, so we're not doing more computation? 
  - 
  - WebGPU general-purpose FCA "solver"
    - NOTE: multiple approaches
      - (a) do the "parallel" full approach suggested by that paper. how would we handle the massive amount of memory?
      - (b) do the next-closure, BUT parallelize the parts (both checking multiple i's, AND parallel-apply of SolutionFormalContext.getClosure/Implication.implicationSetClosure)
  - 
  - TPatternBoard cleanup:
    - 
    - !!!!!! GET RID OF TPatternBoard, just make BasePatternBoard => PatternBoard.
      - Then we can store PatternBoard-related info (e.g. automorphisms, planar mappings, bit-packing metadata) on it
    - 
    - default planar mapping on TPatternBoard
    - 
    - QUICK:
      - Make a "pattern-boards" page that shows pattern boards
        - ESTABLISH a registry of "tiling" types
    - Description and mapping on TPatternBoard(!)
      - Registry of simplest-mapping pattern boards (based on isomorphism)
        - We attach the rules to these
  - 
  - Symmetry pruning
    - Store stacks of choices. Can evaluate whether it is canonical.
    - NOTE: We can calculate AT WHAT stack index we should potentially check for WHAT automorphism!!!
      - Of course, ignore identity automorphism 
      - What if the pattern is equal when the automorphism is applied? (then we will rely on the "filter" later to remove it)
  - 
  - Make a good "viewer" for patterns/rules (ideally one we can scroll through though)
  - 
  - Rules Solver!
    - (for plugging into the UI, puzzle generation, difficulty estimation(!))
    - Performance: PatternRule.withRulesApplied
      - Looks so much like [LinClosure] noted from LinCbO paper.
      - 
      - Make sure to combine embedded rules that have the same embedded input feature set 
      - 
      - PatternRuleApplicator (keep finding matching rules, apply them, then wait for more)
        - PatternRule.isRedundant will:
          - (a) scan for what parts of the rule are "missing" (edges, sectors, faces/duals?)
          - (b) if missing, start an applicator
            - it will find a match, and apply it, then return back to us (noting WHAT CHANGED)
            - we see if we are redundant yet, if not, continue until NO MORE MATCHES
        - Applicator will:
          - Store arrays for (edges, sectors, faces/duals?) that get rules with "those parts missing"
            - Whenever we apply a rule that hits these, we put them "back in the queue"
            - Obviously we ditch rules that can't be applied (incompatible OR not face values)
        - duals for "missing" - can be noted by their canonical string (so we can easily match/remove)
        - 
        - NOTE!!!!!! : For redundancy, we know that rules that are INCONSISTENT with our "output" will never be applied
      - 
      - Rule search tree for fast solving?
      - Dirty rules:
        - Store "dormant" rules with <needs feature> for faster solving
        - Basically "don't keep trying to match rules when we haven't changed any of their input features"
      - ... we could just BAKE the "no simple loops" thing into our rules, with potentially faster checks?
        - Would this reduce the number of rules?
          - !!!!!!!#$!#$!#$
          - #$!#$!#$
          - Yes just include this condition in the "redundancy" check solve
      - Is there a pre-sorting or pre-processing of rules that could be done to make this faster? (besides collapsing)
  - 
  - Face colors!
    - !! How to collapse face color rules nicely? (from exit vertex to... non-exit?)
    - Add the "color matching" so the pattern rules are more... viewable?
  - 
  - WHEN WE SHOW EMBEDDED VERSIONS, execute MULTIPLE PatternRules on the "simpler" embedded version
    - Certain topology (red exit vertex, etc.) features will probably unlock more things
  - Also when we show embedded versions:
    - We have a lot of rules for "preventing simple loops" or "preventing simple loops after we do something trivial"
  - Hex 1-0 has tons of these... anything with an exit vertex on the connection is... essentially not a rule
  - 
  - Check code TODOs
  - 
  - Rule collapse on embedding too (consolidate)
    - (do this in places where we are ... solving?)
  - 
  - Testing
    - SolutionSet unit tests
    - Rule set fuzzing (ensure "random feature set" that is valid is properly solved by our rules)
  - 
  - Highlander with FACE COLORS (!)
  - 
  - Parallel running:
    - https://github.com/deThread/dethread?tab=readme-ov-file / https://socket.io/docs/v4/
  - 
  - FeatureSet.difference (things we can apply, essentially the pattern rule output)
    - (performance, but also "hey we can show what actually changed")
    - Also, our matching is partially based on this(!)
  - 
  - Highlander canonical:
    - For each solution, we can extract out the string for its (a) indeterminate edges, and (b) exit connections in a canonical form
      - Easily allows searching for highlander-duplicates
  - [ HEY HEY!!!! ]
    - Let's just output both FeatureSets of non-highlander AND highlander (from the solve process)
  - 
  - Matching!!!
    - !!! Match exit edges (red) with either absence or just red edges. no white/black!
    - ... Almost everything else needs to have an exact analogue? (sectors, face colors, non-exit edge features, etc.)
  - 
  - !!! For feature equality (of a list that is nonredundant) - just get canonical strings, sort, append, compare!
    - NOTE: We can't exactly deduplicate embeddings with this, due to FACE COLOR DUALS that start to "overlap"
      - HEY, for embeddings, COMBINE FACE COLOR DUALS that have overlap(!)
        - embedFeatures( features ) => features, handles overlapping things (face color duals) and removes redundancies
          - then sort to "canonical order"?
  - 
  - View for pattern - canonicalize which face features get which coloring (lowest index ordering) so those don't... change? hmm awkward
    - We... actually want to try to keep face colors consistent? (allow passing in a previous mapping?)
  - 
  - !!!! When we have a set of features we are adding, we can potentially RULE OUT other features (intelligent exploration)
    - e.g. pick face color features. we can then use the solver to enumerate all solutions, and RULE OUT other features that are not present in any solution
  - 
  - [NOTE: not a bottleneck for patterns] Can we use Solver.solveAssuming
  - 
  - NOTE: Handle FaceColorDualFeature differently, no redundancy checking
  - 
  - Face Color Annoyance:
    - DO SMART FACE COLOR DUAL features? (not... named?)
      - Storing duals means:
        - (1) FASTER matching (since we don't do O(n^2) checks for large regions)
        - (2) Can provide the exhaustive O(n^2) for computing all solutions and analyzing
        - (3) our "output" state change can be a "list of the face color actions needed to be done"
    - Our booleans are VERY over-specified. Are dual-color with faces representations possible?
      - (though this is... so simple)
      - HEY this causes our logic-solver to get a LOT of complicated rules that it probably doesn't need(!), O(n^2)
        - O(n^2)!!!!!!!!!!!!! 
      - Could just be consistent and compute duals, and:
        - (a) fully specify all color relations based on the relationships (fill them out)
        - (b) minimize them when we actually... scan for patterns?
  - 
  - "Constraints" vs "Features"
    - Constraints: We add constraints at the start of solving, and they don't change
      - (can use Feature interface for adding solving constraints) 
      - Highlander
      - [defer] Nonzero-crossing (NEW: 2+ crossing) - both could be used in the future
      - [defer] NEW: certain exit vertices NEED to connect together? Or need NOT to?
      - Vertex 0-or-2 rules
      - Face values (including blank)
    - Features:
      - .. All the other things we are used to
  - 
  - Highlander:
    - Q: Do we need to iterate through all solutions for highlander?
      - Can "hash" highlander solutions by:
        - (a) string of booleans (one per indeterminate edge)
        - (b) lexicographically ordered "exit vertex (or edge) index pairs that are connected", e.g. 0-5, 2-3, etc. (exit vertex 0 connects to exit vertex 5)
    - Edges that are adjacent to an exit-face OR non-valued (non-blank) face are "indeterminate" edges (exit edges are indeterminate)
    - Two solutions with the same values on indeterminate edges AND same exit connections are both excluded in highlander rules
    - NOTE(!) Highlander rules might NOT require blank faces (especially once sectors and colors are in play)
      - (we will have highlander color rules)
    - How to mark/display these? question marks on unspecified faces?
  - 
  - Storage/Serialization of patternboards / patterns / rules
    - PatternBoard
      - Naming prefixes? square, "4x4" for "there are four 4-order faces"? not sure how we would disambiguate
        - Actually, fixed strings for the "edge/vertex" ones, and... STORE the face indices in a string for the face ones?
    - We want to consolidate references to PatternBoards, so that the embeddings computation is "spread across all the rules"
    - Wait, CAN WE skip storing the mappings, since we can just find embeddings in tilings and report those out?
      - But... we should determine isomorphic pattern boards... take in strings and cache isomorphic ones?
        - Would we need to "remap" patterns/rules?
  - 
  - PatternEmbeddingNode - PatternBoard in PatternBoard (without state at first)
  - 
  - Pattern = pattern-board + pattern-state (features?)
    - Face values are part of the pattern/features, no? 
    - How to think of highlander?
  - 
  - [defer] Nonzero (or 2+) crossing type - compute possible paths
  - 
  - !!!!!!!!!
  - !!! Find all embeddings of a specific (shared) patternboard in a board-pattern-board
  - !!!!! THEN GET the "current features/state" of it (from the board+puzzle=state) => "featured board" so we can scan efficiently
  - !!! (extract features from board+state, into a featured board)
  - !!!!!!!!!
  - We do NOT apply "black exit edges" with the pattern, or exit sectors, etc. Keep things simpler, rely in "larger" patterns for those
  - Vertex topology updates to be... like there are "face portions" and non-face portions
    - [no] WAIT, are most "vertex" rules... really "face" rules???
      - NO NO, we really DO have vertex topology setups 
  - [ignore, we will not infer in invalid puzzle] How to "pattern match" an "exit edge" if it will contain... 2 black? (patterns will not really apply well)

- We are able to apply patterns without OR WITH the "topological simplification"(!)
  - Ooo, this might be good for generating puzzles?

- Assume patterns/rules only applied if they don't include the entire solution (can't be the loop, loops prevented)

[API needs to be compatible with boards, maybe with adapter]
  - Can we put an 'index' on everything in a board?

- [defer] "Invalidity" patterns?

- Running through all SAT solutions is possible, but can do better
  - First, do pre-checks (quick) to see if the pattern is clearly impossible 
  - Keep a running list of loops (that will always be negated)
  - FIRST find a no-added-constraint no-loop solution
    - IF none, then the pattern won't occur in a valid puzzle
  - If a no-loop solution is found, mark all of the POSSIBLE things immediately.
  - After we have one solution, we can:
    - Find a NOT_FOUND boolean, restart with a constraint that it must be possible, and see if we can find a solution:
      - If we can't, mark it IMPOSSIBLE
      - If we can, do the normal "mark POSSIBLE" things and start again with another NOT_FOUND BOOLEAN
    - NOTE: Might be more efficient to run through a fixed (N=10) number of solutions, to get more possible bits?

- Exit edge decisions:
  - Ignore "black" exit edges (no feature for that both for input and output).
  - No sectors for exit edges (no feature for that both for input and output).

- PatternBoard:
  - [defer] Generation: 
    - [defer] Prevent combinations where... a face isn't included but all of its neighbors are? (or perhaps... if all its vertices are included, include it?) THINK
  - [defer] Canonicalize:
    - [defer] Find the vertex permutation that gives us the lexicographically smallest order of states.
    - [defer] Then we can use equality to check isomorphism (and we can store this in a hash table)

https://github.com/timhutton/slinker ---> has the "solving rules"
Review https://github.com/timhutton/slinker/blob/main/src/SlinkerGrid.cpp !!!!

[this is mostly old, refresh it]:

- Topology-invariance (full):
  - Make a pattern. Can "add" topo-invariant things to it with a match.
  - 
  - Same as our topological bit, BUT REVERSE the simplification when matching?
  - RED edges mostly disappear or no?
  - IF we deal with a single part of a face, we can "generalize" the rest of the face?
  - RED EDGES essentially CHANGES the topology
    - Make rules that can be applied to ANY cases 

[Deprecated]

- [deprecated - use implication search] "Solution Search" Performance wins:
  - (!!!!!!!!) - What if we do a BFS-like search (but keeping canonical at each step?)
    - This gets us "instant incremental"
    - WOULD NEED TO BRING BACK THAT "DUAL"
    - ---- wait, won't this take up a LOT of memory? (!)
  - (!!!) WE can use "output feature sets" / solution sets to ACCELERATE the search?
    - If we have said feature sets A => B, then it makes no sense testing anything between A and B
    - WAIT think about this (recall, if we are going for MINIMAL, there might be A* with a different feature that is minimal)
      - And thus we can't just "skip" to B
        - (!!!) WAIT, but we CAN just "delay" those features, and focus on others (since exploring them will give no info)
          - (!!!!!!!)
            - Can we "choose" features to select, based on their frequency?
              - Will splitting with a more "binary" search be more efficient?
              - CAN WE INITIALLY ORDER FEATURES so that the isomorphism checks can prune large amounts?
                - ... e.g. start with unique "corners", if we have set all N of what it can map to, we can
                  - START SYMMETRY PRUNING.
                - (obviously, don't do this on boards with only the identity isomorphism)
    - BUT BUT we can just... do a "quick check" when it's time to decide a feature, see if it can only take one path(!)
      - This is almost... like a "skip"
  - (!) OMG keep the rule that we "branched" from, and see if it directly solves the next one (with a single feature added)
    - Possibly with a tiny subset of features?
  - (x) Don't use that "stack", just pass parameters?
  - (a) minimize amount of new objects created for each SolutionFeatureSet
    - can we store just a "row index" of the solutions? lightweight view
    - can we store just a "new feature" list? Why are we... doing FeatureSets? ---- OMG why are we storing FeatureSets?
  - (c) potentially prune automorphisms EARLIER!
    - We could at least do automorphism/canonical checks AT END OF FACES(!)
- [deprecated, solved by implication search] 3-face colors running into... generateAllDisjointNonSingleSubsets blowing UP!!!
  - ... do we just make this more of a callback iterator (or generator)?
