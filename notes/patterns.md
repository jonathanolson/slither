
# Patterns

- TODO
  - 
  - Generate:
    - Current:
      - getImpliedColorSquareBoardRules( 2, 0 )
      - getImpliedColorSquareBoardRules( 2, 4 )
      - getOnlyImpliedSquareBoardRules( 3, 11 )
      - getOnlyImpliedSquareBoardRules( 3, 18 )
    - Future:
      - Highlander on smaller boards(!)
      - getOnlyImpliedSectorSquareBoardRules( 2, 0 )
      - getOnlyImpliedSectorSquareBoardRules( 2, 1 )
      - getOnlyImpliedSectorSquareBoardRules( 2, 2 )
      - getOnlyImpliedSectorSquareBoardRules( 2, 3 )
      - getOnlyImpliedSectorSquareBoardRules( 2, 4 )
      - [once square 3, x] getOnlyImpliedSquareBoardRules( 0, 4 ) THEN HIGHLANDER
  - 
  - HEY! getEmbeddedRules might be giving us some "duplicates". I think we were filtering these out before
    - Filter these out where possible, so we're not doing more computation? 
  - 
  - FeatureSet "only one" is... weird to store. It is essentially true if not-zero and not-two (redundant)
  - 
  - Sector solving... still buggy
    - Check if isomorphism checks for sector rules aren't working (e.g. 3-edge + exit, 2 adjacent sector)
  - 
  - Test implied-highlander (... to check our GOOD case, we need all of level-3 square, and the specific level-4 square)
  - 
  - WebGPU general-purpose FCA "solver"
  - 
  - Fix up generation (we broke some things?)
  - 
  - Clean up all SORTS of code. See if FCA approach is widely better in all ways.
  - 
  - deduplication of pattern board instances, based on isomorphism
  - 
  - Testing...
    - 
    - Make sure that pattern rules in lists are "minimal" (individually remove input features and they should ALL change the output features)
    - 
    - 
    - WAIT WAIT .... is that just how we check redundancy?
  - 
  - Bitmasks... for FeatureSets (.... oh, and duals are solved by the pair bits?)
    - Binary bitpacked array helper methods. 
    - BinaryFeatureSet
    - SolutionSet potential refactor:
      - (a) add BinaryFeatureSet output
      - (b) move "original is black" bits out to a contiguous chunk at the end of the array
    - Flags:
        - NOTE NOTE: WE HAVE OVERLAP between opposite/same (for adjacent faces) and the notred/notblack equivalent
        - Do we... deduplicate this data?
        - --- also exit edges only need a bit for "is red"?
      - Not red (e.g. black)
      - Not black (e.g. red)
      - Not zero
      - Not one
      - Not two (how should the flags detect with red/black?)
        - OMG OMG what if we store a certain number of EDGES per number, and we DO NOT SPLIT
          - Then we can BIT SHIFT to potentially check sectors(!!!!!!!!).e.g. "do we need a feature for this, or is it redundant"
      - Not opposite
      - Not same
      - Original is black (solution only)
    - Everything becomes "finding boolean formulas" now
  - 
  - TPatternBoard cleanup:
    - 
    - !!!!!! GET RID OF TPatternBoard, just make BasePatternBoard => PatternBoard.
      - Then we can store PatternBoard-related info (e.g. automorphisms, planar mappings, bit-packing metadata) on it
    - 
    - default planar mapping on TPatternBoard
    - 
    - QUICK:
      - Make a "pattern-boards" page that shows pattern boards
        - ESTABLISH a registry of "tiling" types
    - Description and mapping on TPatternBoard(!)
      - Registry of simplest-mapping pattern boards (based on isomorphism)
        - We attach the rules to these
  - 
  - Symmetry pruning
    - Store stacks of choices. Can evaluate whether it is canonical.
    - NOTE: We can calculate AT WHAT stack index we should potentially check for WHAT automorphism!!!
      - Of course, ignore identity automorphism 
      - What if the pattern is equal when the automorphism is applied? (then we will rely on the "filter" later to remove it)
  - 
  - Have rule-image.ts write all of the files out based on pattern-set?
    - Use puppeteer, provide a function that gives the image?
    - Use svgo (minus the viewbox removal) to optimize the files
  - 
  - Potentially something that lists/gives "serialization" for pattern boards/mappings
  - Make a good "viewer" for patterns (ideally one we can scroll through though)
  - 
  - Performance: PatternRule.withRulesApplied
    - 
    - PatternRuleApplicator (keep finding matching rules, apply them, then wait for more)
      - PatternRule.isRedundant will:
        - (a) scan for what parts of the rule are "missing" (edges, sectors, faces/duals?)
        - (b) if missing, start an applicator
          - it will find a match, and apply it, then return back to us (noting WHAT CHANGED)
          - we see if we are redundant yet, if not, continue until NO MORE MATCHES
      - Applicator will:
        - Store arrays for (edges, sectors, faces/duals?) that get rules with "those parts missing"
          - Whenever we apply a rule that hits these, we put them "back in the queue"
          - Obviously we ditch rules that can't be applied (incompatible OR not face values)
      - duals for "missing" - can be noted by their canonical string (so we can easily match/remove)
      - 
      - NOTE!!!!!! : For redundancy, we know that rules that are INCONSISTENT with our "output" will never be applied
    - 
    - Rule search tree for fast solving?
    - Dirty rules:
      - Store "dormant" rules with <needs feature> for faster solving
      - Basically "don't keep trying to match rules when we haven't changed any of their input features"
    - ... we could just BAKE the "no simple loops" thing into our rules, with potentially faster checks?
      - Would this reduce the number of rules?
        - !!!!!!!#$!#$!#$
        - #$!#$!#$
        - Yes just include this condition in the "redundancy" check solve
    - Is there a pre-sorting or pre-processing of rules that could be done to make this faster? (besides collapsing)
  - 
  - 3-face colors running into... generateAllDisjointNonSingleSubsets blowing UP!!!
    - ... do we just make this more of a callback iterator (or generator)?
  - 
  - Compute face colors for other boards (at least gen 0 and 1)
  - 
  - It seems like progressive is SLOWING things down! Maybe lets just store a flag and call the callback once?
  - 
  - Face colors!
    - !! How to collapse face color rules nicely? (from exit vertex to... non-exit?)
    - Add the "color matching" so the pattern rules are more... viewable?
  - 
  - rule-gen failure in dev (circular) https://github.com/vitejs/vite/issues/3033#issuecomment-973247243
  - 
  - "initial feature set" for PatternRule.getSolutionEnumeratedRules (for "only")
    - e.g. "red exit edges" for vertices for square/hex patterns ("only")
    - remove faces/edges from the list at start time?
      - remove face color dual combinations that are incompatible at start time?
    - [ready to go, should allow squareOnly/hexOnly searches to be faster]
    - NOTE: For face coloring, we'd really want ... multiple initial feature sets (permutations?)
      - Imagine 3 squares diagonal pattern. Yes red exit vertices (2), BUT we can't just FIX face colors, because multiple embeddings(!)
  - 
  - Sectors (it will reduce pattern rule count considerably?)
  - Highlander rules (!)
  - 
  - Performance: PatternRule.getSolutionEnumeratedRules
    - Can we filter "satisfied" previous rules out?
      - This requires more expensive checks. Could see if a rule's outputFeatureSet has our change (and only check then)
      - If rule.outputFeatureSet.isSubsetOf( ... featureSet ) <--- requires computing featureSet?
  - 
  - STATIC patterns!!!! JUST SEARCH FACES
    - ... do we only report these if... removing ANY of the faces would then give no information?
      - Or do we allow a certain number of "red exit vertices"?
  - 
  - See top performance wins (below)
  - 
  - Should be possible to take "square only" rules, take embeddings in square board, only take (1) as representative
    - Note: will need to "apply" initial conditions to this section
  - 
  - Verify rules!
  - 
  - WHEN WE SHOW EMBEDDED VERSIONS, execute MULTIPLE PatternRules on the "simpler" embedded version
    - Certain topology (red exit vertex, etc.) features will probably unlock more things
  - Also when we show embedded versions:
    - We have a lot of rules for "preventing simple loops" or "preventing simple loops after we do something trivial"
  - Hex 1-0 has tons of these... anything with an exit vertex on the connection is... essentially not a rule
  - 
  - Rules "Solver" (for plugging into the UI, puzzle generation, difficulty estimation(!))
    - How to "apply multiple rules" for a given... embedding*?
      - OH OH, check all rule input feature sets. Then COMBINE embedded rules that are "compatible"?
        - If their input feature sets are the same, combine them!!!
  - 
  - Check code TODOs
  - 
  - Performance wins:
    - (!!!!!!!!) - What if we do a BFS-like search (but keeping canonical at each step?)
      - This gets us "instant incremental"
      - WOULD NEED TO BRING BACK THAT "DUAL"
      - ---- wait, won't this take up a LOT of memory? (!)
    - (!!!) WE can use "output feature sets" / solution sets to ACCELERATE the search?
      - If we have said feature sets A => B, then it makes no sense testing anything between A and B
      - WAIT think about this (recall, if we are going for MINIMAL, there might be A* with a different feature that is minimal)
        - And thus we can't just "skip" to B
          - (!!!) WAIT, but we CAN just "delay" those features, and focus on others (since exploring them will give no info)
            - (!!!!!!!)
              - Can we "choose" features to select, based on their frequency?
                - Will splitting with a more "binary" search be more efficient?
                - CAN WE INITIALLY ORDER FEATURES so that the isomorphism checks can prune large amounts?
                  - ... e.g. start with unique "corners", if we have set all N of what it can map to, we can
                    - START SYMMETRY PRUNING.
                  - (obviously, don't do this on boards with only the identity isomorphism)
      - BUT BUT we can just... do a "quick check" when it's time to decide a feature, see if it can only take one path(!)
        - This is almost... like a "skip"
    - (!) OMG keep the rule that we "branched" from, and see if it directly solves the next one (with a single feature added)
      - Possibly with a tiny subset of features?
    - (x) Don't use that "stack", just pass parameters?
    - (a) minimize amount of new objects created for each SolutionFeatureSet
      - can we store just a "row index" of the solutions? lightweight view
      - can we store just a "new feature" list? Why are we... doing FeatureSets? ---- OMG why are we storing FeatureSets?
    - (c) potentially prune automorphisms EARLIER!
      - We could at least do automorphism/canonical checks AT END OF FACES(!)
  - 
  - Rule collapse on embedding too (consolidate)
    - (do this in places where we are ... solving?)
  - 
  - [defer] Performance: WebGPU
    - This... seems hard. But wait, this is actually really more of a BITMASK situation. See how JS "prototype" goes
      - This would be AMAZING for performance
  - 
  - SolutionSet unit tests(!!!!)
    - Also check "random feature set" combinations, ensure that our "filtered" rules solve all of the cases correctly.
  - 
  - UNIT TESTS --- also test that things are "solving" correctly, e.g. given a random feature set WITH solutions,
  -   things that are solved keep the same solution count/set
  - 
  - Highlander with FACE COLORS (!)
  - 
  - During simulations, we COULD ignore exit edges (since they are determined by the rest of the puzzle)
  - 
  - Parallel running:
    - https://github.com/deThread/dethread?tab=readme-ov-file / https://socket.io/docs/v4/
  - 
  - FeatureSet.difference (things we can apply, essentially the pattern rule output)
    - (performance, but also "hey we can show what actually changed")
    - Also, our matching is partially based on this(!)
  - 
  - Deprecate getEdgeConnectedComponentFaces (use FaceConnectivity instead)
  - 
  - Enumerate initial feature sets (given a pattern board) for:
    1. Edges
    2. Face Colors
    3. Edges + Sectors
    4. Edges + Face Colors
    5. All
  - 
  - Organization:
    - Automorphisms?
    - How do we cache embeddings between PatternBoards?
      - We just... have a global cache, no?
        - [but... no weakmap on TPatternBoard] NONO, weakmap it!!!!
        - [instead] just have a two-layer global weakmap. 
    - 
    - OMG TPatternBoard being an interface is... killing us?
    - 
    - PatternBoard (without description)?!?
    - WITH DESCRIPTION
    - WITH MAPPING (?) less important
    - --- with automorphisms?
      - Later, for solving... finding valid embeddings(!) 
  - 
  - Highlander canonical:
    - For each solution, we can extract out the string for its (a) indeterminate edges, and (b) exit connections in a canonical form
      - Easily allows searching for highlander-duplicates
  - [ HEY HEY!!!! ]
    - Let's just output both FeatureSets of non-highlander AND highlander (from the solve process)
  - 
  - Matching!!!
    - !!! Match exit edges (red) with either absence or just red edges. no white/black!
    - ... Almost everything else needs to have an exact analogue? (sectors, face colors, non-exit edge features, etc.)
  - 
  - !!! For feature equality (of a list that is nonredundant) - just get canonical strings, sort, append, compare!
    - NOTE: We can't exactly deduplicate embeddings with this, due to FACE COLOR DUALS that start to "overlap"
      - HEY, for embeddings, COMBINE FACE COLOR DUALS that have overlap(!)
        - embedFeatures( features ) => features, handles overlapping things (face color duals) and removes redundancies
          - then sort to "canonical order"?
  - 
  - Database of pattern boards (with mappings).
    - So we can manually create a pattern board and FIND an equivalent mapping through it(!)
    - CANONICALIZATION somehow? or just scan for isomorphisms?
    - move out sketchyIsIsomorphic into a function in code
  - 
  - Get automorphisms from a pattern board
  - Get all edge features
  - Get all face color dual feature combinations
  - [ ... ] create patterns (verify at least one solution in the solver)
  - DEDUPLICATE? (with automorphisms)
  - 
  - View for pattern - canonicalize which face features get which coloring (lowest index ordering) so those don't... change? hmm awkward
    - We... actually want to try to keep face colors consistent? (allow passing in a previous mapping?)
  - 
  - !!!! When we have a set of features we are adding, we can potentially RULE OUT other features (intelligent exploration)
    - e.g. pick face color features. we can then use the solver to enumerate all solutions, and RULE OUT other features that are not present in any solution
  - 
  - Add "feature creation" from pattern board
  - 
  - Can we use Solver.solveAssuming
  - 
  - NOTE: Handle FaceColorDualFeature differently, no redundancy checking
  - 
  - Face Color Annoyance:
    - DO SMART FACE COLOR DUAL features? (not... named?)
      - Storing duals means:
        - (1) FASTER matching (since we don't do O(n^2) checks for large regions)
        - (2) Can provide the exhaustive O(n^2) for computing all solutions and analyzing
        - (3) our "output" state change can be a "list of the face color actions needed to be done"
    - Our booleans are VERY over-specified. Are dual-color with faces representations possible?
      - (though this is... so simple)
      - HEY this causes our logic-solver to get a LOT of complicated rules that it probably doesn't need(!), O(n^2)
        - O(n^2)!!!!!!!!!!!!! 
      - Could just be consistent and compute duals, and:
        - (a) fully specify all color relations based on the relationships (fill them out)
        - (b) minimize them when we actually... scan for patterns?
  - 
  - "Constraints" vs "Features"
    - Constraints: We add constraints at the start of solving, and they don't change
      - (can use Feature interface for adding solving constraints) 
      - Highlander
      - [defer] Nonzero-crossing (NEW: 2+ crossing) - both could be used in the future
      - [defer] NEW: certain exit vertices NEED to connect together? Or need NOT to?
      - Vertex 0-or-2 rules
      - Face values (including blank)
    - Features:
      - .. All the other things we are used to
  - 
  - Highlander:
    - STORE WHETHER A RULE/PATTERN IS HIGHLANDER(!)
    - Q: Do we need to iterate through all solutions for highlander?
      - Can "hash" highlander solutions by:
        - (a) string of booleans (one per indeterminate edge)
        - (b) lexicographically ordered "exit vertex (or edge) index pairs that are connected", e.g. 0-5, 2-3, etc. (exit vertex 0 connects to exit vertex 5)
    - Edges that are adjacent to an exit-face OR non-valued (non-blank) face are "indeterminate" edges (exit edges are indeterminate)
    - Two solutions with the same values on indeterminate edges AND same exit connections are both excluded in highlander rules
    - NOTE(!) Highlander rules might NOT require blank faces (especially once sectors and colors are in play)
      - (we will have highlander color rules)
    - How to mark/display these? question marks on unspecified faces?
  - 
  - Storage/Serialization of patternboards / patterns / rules
    - PatternBoard
      - Naming prefixes? square, "4x4" for "there are four 4-order faces"? not sure how we would disambiguate
        - Actually, fixed strings for the "edge/vertex" ones, and... STORE the face indices in a string for the face ones?
    - We want to consolidate references to PatternBoards, so that the embeddings computation is "spread across all the rules"
    - Wait, CAN WE skip storing the mappings, since we can just find embeddings in tilings and report those out?
      - But... we should determine isomorphic pattern boards... take in strings and cache isomorphic ones?
        - Would we need to "remap" patterns/rules?
  - 
  - PatternEmbeddingNode - PatternBoard in PatternBoard (without state at first)
  - 
  - Pattern = pattern-board + pattern-state (features?)
    - Face values are part of the pattern/features, no? 
    - How to think of highlander?
  - 
  - [defer] Nonzero (or 2+) crossing type - compute possible paths
  - 
  - !!!!!!!!!
  - !!! Find all embeddings of a specific (shared) patternboard in a board-pattern-board
  - !!!!! THEN GET the "current features/state" of it (from the board+puzzle=state) => "featured board" so we can scan efficiently
  - !!! (extract features from board+state, into a featured board)
  - !!!!!!!!!
  - We do NOT apply "black exit edges" with the pattern, or exit sectors, etc. Keep things simpler, rely in "larger" patterns for those
  - Vertex topology updates to be... like there are "face portions" and non-face portions
    - [no] WAIT, are most "vertex" rules... really "face" rules???
      - NO NO, we really DO have vertex topology setups 
  - [ignore, we will not infer in invalid puzzle] How to "pattern match" an "exit edge" if it will contain... 2 black? (patterns will not really apply well)

- We are able to apply patterns without OR WITH the "topological simplification"(!)
  - Ooo, this might be good for generating puzzles?

- Assume patterns/rules only applied if they don't include the entire solution (can't be the loop, loops prevented)

[API needs to be compatible with boards, maybe with adapter]
  - Can we put an 'index' on everything in a board?

- Each boolean will be on a state:
  - NOT_FOUND (initial state)
  - POSSIBLE
  - IMPOSSIBLE

- Automorphisms?
- [defer] "Invalidity" patterns?

- Running through all SAT solutions is possible, but can do better
  - First, do pre-checks (quick) to see if the pattern is clearly impossible 
  - Keep a running list of loops (that will always be negated)
  - FIRST find a no-added-constraint no-loop solution
    - IF none, then the pattern won't occur in a valid puzzle
  - If a no-loop solution is found, mark all of the POSSIBLE things immediately.
  - After we have one solution, we can:
    - Find a NOT_FOUND boolean, restart with a constraint that it must be possible, and see if we can find a solution:
      - If we can't, mark it IMPOSSIBLE
      - If we can, do the normal "mark POSSIBLE" things and start again with another NOT_FOUND BOOLEAN
    - NOTE: Might be more efficient to run through a fixed (N=10) number of solutions, to get more possible bits?

- Exit edge decisions:
  - Ignore "black" exit edges (no feature for that both for input and output).
  - No sectors for exit edges (no feature for that both for input and output).

- Vertex rule count
  - Order 6 typical, but order 12 for Triakis Triangular / Bisected Hexagonal... 8 for Tetrakis Square

- PatternBoard:
  - [defer] Generation: 
    - [defer] Prevent combinations where... a face isn't included but all of its neighbors are? (or perhaps... if all its vertices are included, include it?) THINK
  - [defer] Canonicalize:
    - [defer] Find the vertex permutation that gives us the lexicographically smallest order of states.
    - [defer] Then we can use equality to check isomorphism (and we can store this in a hash table)

- Flexible BUT NOT TOPO-invariant (no red edge removal, but we generate face combinations):
  - FaceRule
    - FaceRule application to:
      - A puzzle (with a board)
      - A FaceRule state(!) so we can directly see what rules "dominate" others, and construct a minimal set of rules.
        - OR... we just have things create a matching puzzle (board+state), and then apply to that board?
          - Padding is complicated.... nah
        - Yeah, just find subgraph isomorphisms and check?
    - Visualization
      - Direct (the pattern data itself)
        - How to show "exit" edges for "twist" vertices?
      - Indirect (examples on a board)
        - For viz, we search for possible occurrences in a tiling (there might be a good number, can we enumerate?)
          - See where it applies, cut faces too far from the pattern (or create a grid view around it, and clip)
    - If rules have isomorphic topologies, check these (multiple?) isomorphisms to see if they are isomorphic rules(!)
    - "FlexBoard" should be memoized, so that we can store computed automorphisms (and subgraph isomorphisms)
      - And... SHARED between rules!
      - Automorphisms (can be used be rules to see if they have symmetries in input)
      - List all of the potential features (boolean values)
        - (follow "state" boolean conventions, true means "this configuration is possible")
        - Feature
          - Ability to add SAT condition

https://github.com/timhutton/slinker ---> has the "solving rules"
Review https://github.com/timhutton/slinker/blob/main/src/SlinkerGrid.cpp !!!!

[this is mostly old, refresh it]:

- Topology-invariance (full):
  - Make a pattern. Can "add" topo-invariant things to it with a match.
  - 
  - Same as our topological bit, BUT REVERSE the simplification when matching?
  - RED edges mostly disappear or no?
  - IF we deal with a single part of a face, we can "generalize" the rest of the face?
  - RED EDGES essentially CHANGES the topology
    - Make rules that can be applied to ANY cases 
