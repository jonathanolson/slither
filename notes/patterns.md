
# Patterns

- TODO
  - 
  - DO THE LOCALE STUFF, and then... sneak and phet-lib TS so we don't keep having all of the chunk issues? hopefully?
  - 
  - OMG, allow my "rule.html" bit to import... just ANY input pattern (board + features)!
  - 
  - 
  - CLEANUP:
    - getFeatureImpliedRules / SolutionFormalContext / SolutionAttributeSet / PatternAttributeSetMapping
    - 
    - RichSolution
    - BinaryFeatureMap - given PatternBoard and edge/sector/face-dual/highlander options
      - List (at least one) TFeature for each bit!!! - will have edge/color-dual OVERLAP of features specified
      - Allow various reads/writes on bigints based on features (with methods)
      - WHEN READING BACK INTO A FEATURESET:
        - Check for "invalid" (null) - e.g. all bits set
        - Do a lot of what SolutionSet.applyNumbersToFeatureSet does now?
          - BUT pull efficient face-color code eventually from that one place?
    - For closures:
      - RichSolutionFinder - given a bigint/attributeset, give a (pruned) list of RichSolutions we should search through
        - [HELPFUL] - For those red exit edges, ALSO prune the solutions based on this (AFTER the highlander bit)
      - easy to get "getClosure" from a finder (should be consistent) - NOTE the potential "optional data"
        - HEY, these should INSTEAD directly give us SolutionAttributeSets?
          - [HEY] SolutionAttributeSet DIRECTLY on RichSolution?
    - 
    - Remember, bits are:
      - non-exit edges: RED, BLACK
        - If solution:black, set BLACK
        - If solution:red, set RED
      - exit edges: RED
        - If solution:red AND exit vertex has a black (non-exit) edge, set RED (since it is a forced red)
      - sectors: NOT_ZERO, NOT_ONE, NOT_TWO
        - (set as normal)
      - OTHER face pairs (that don't have a single edge based on FaceConnectivity): SAME, OPPOSITE
        - (check parity, using shortestPath), set the appropriate bit
    - VertexConnections:
      - Use the SolutionSet algos, line 760ish
    - 
    - [OOO] - If none of the potential solutions has vertex connection overlap, we gain no information from highlander (and could skip)
    - 
    - Order of operations:
      - Solutions, from PatternBoardSolver.forEachSolution( featureSet.patternBoard, featureSet.getFeaturesArray(), callback )
        - Store solution: TPatternEdge[],
        - Store solutionSet: Set<TPatternEdge>
        - Store main bigint (attribute set)
        - Store optional bigint (optional set, indicating exit edges soft-red-or-double-black, with no black non-exit edges)
        - Store vertex connections (and string key?)
    - 
    - SKIP the SolutionSet(!), but perhaps do things that it does?
  - 
  - I've made a rats nest basing things on SolutionSet. Just create a `Solution` type(!) for ease of use
  - 
  - DIRECT from PatternBoardSolver => SolutionFormalContext, with IMPROVED solution objects!
  - 
  - FOR HIGHLANDER:
    - Calculate the list of solutions for EVERY binary combination of "is it red exit edge" states.
      - Store in array where array[ index: binary-exit-edges ] = [ list of solutions ]
      - 
      - OMFG, for the start, to validate the idea, JUST raw compute the filter every time? (ooof, is this bad perf quick?)
        - Actually, the initial ones don't have a HUGE amount of solutions, this is NOT ABSOLUTELY horrible
      - 
      - Compute all bins for the "BASE STATE", and what their numeric bins are.
      - Then start recursively going through the "unset exit edges", trying both SET and NOT.
        - When SETTING to red, combine bins so we have fast computation
          - [HOW TO COMBINE] - can we still use bigints to index these? How can we stuff connection data in? (that is a lot of bits?)
            - [WE DO NOT NEED HIGH PERFORMANCE BINNING] - We do it at the start, we can just fall back to strings now
            - Just get the "new" bin ID from a single exemplar from each bin.
            - DITCH bins that are now "excluded" because of red exits (so amount of bins will get smaller)
              - [WAIT can we ditch bins???] - if we need to track "excluded" (so they can be joined)...?
            - THIS WILL hit to cases where we just don't have any bins anymore (invalid subtrees)
      - [TODO]: DO we ... do anything special for when we START with red exit edges?
        - We could just process those at the start, and then "skip" in the recursion. How to index things?
      - Bin identifiers (ordered):
        - Indeterminate non-exit edge: 0,1 for red/black.
        - Exit edge: 1 for black, 0 for hard-red, 2 for red-or-double-black
        - Vertex connections [MAKE SURE SORTED]
          - `,c${min}-${max}` for each --- precompute this for the solutions (since it won't change)
      - 
      - Should be SAFE to do the normal bin/filter
      - BUT if we do this recursively, and actually COMPUTE which bins get combined, it will be way faster
        - (this could be a bottleneck)
    - THEN lookup for the closure, INSTEAD of doing filtering dynamically(!!!) - massive performance win probably
      - This... LETS US DO HIGHLANDER almost on par with others (besides the blank exit faces adding complexity)
    - 
    - Solutions with different vertex connections are NEVER in the same bin
      - Corollary: Solutions with a black exit edge are NEVER in the same bin as a hard-red or soft-red-or-double-black
      - Corollary: Adding a red exit edge as a feature will ONLY (a) filter out bins with black exit edges, and (b) combine bins with hard-red and soft-red-or-double-black exits
        - IMPORTANT: It will never INVALIDATE only part of a bin.
    - 
    - Include vertex connection info in bins
    - 
    - If we have STARTING CONDITIONS (e.g. "only square"), we should only start with solutions to that.
    - 
    - For every binary combination of exit edge state, COMPUTE a list of solutions(!)
      - THEN WE ALSO WILL NOT NEED TO FILTER AFTER THIS(!) and we can get the full speed-up solution
      - But don't single/double prune solution lists if this is the case
      - CONSTRUCT ALL OF THESE as a closure system directly!!! So both:
        - (a) filter out solutions that 
      - WAIT: if it is a closure, we have the "intersections" property of closures, no? Hmmm...
        - Can we "intersect" (ALL of the previou ones)? That seems... expensive on its own?
    - --- ADD indices to solutions (so we can merge them efficiently)
  - 
  - Omg, stop piping everything through SolutionSet when we're using a different binary format. Go direct.
  - 
  - Get our highlander FILTER working with the bins INCLUDING exit edges, so we can run this on the "real" data
    - e.g. show it in rule.html
  - 
  - Run a ton of "completed puzzle testing" for RANDOM puzzles.
    - Ensure that highlander and other rules are ALWAYS correct within these! (VERY MUCH HIGHLANDER)
  - 
  - [future] - we can solve based on vertex connection info, could this be a feature/constraint in the future?
    - Constraint!!!
  - 
  - Generate:
    - HEY HEY -- highlander can be added like "only"? 
    - Current:
      - getOnlyImpliedSectorHexBoardRules 1 0 [kitty 0] <--- last one
      - getImpliedSectorGeneralBoardRules 1 2 [kitty 1] <--- last one!
      - getImpliedColorHexBoardRules 1 0 [kitty 2] <--- #132, but OMG it is chugging!!!
      - 
      - Missing:
        - getImpliedGeneralBoardRules 2 47,48 (MEMORY FAILURES minisat) 
        - getOnlyImpliedSquareBoardRules 4 9 <--- crash on complete? is it in console history? Try on browser direct macOS?
      - 
      - getImpliedColorGeneralBoardRules 1 2 [PC #132 - eeek] -- last of its type
      - getImpliedGeneralBoardRules 2 7 [PC + #46 ek + restart]
      - getImpliedGeneralBoardRules 2 46 [PC] <--- hahah OMG 101415 solutions(!) (at least minisat didn't die)
      - getImpliedGeneralBoardRules 2 52 [PC]
      - getImpliedGeneralBoardRules 2 54 [PC]
      - getOnlyImpliedSquareBoardRules 4 15 [PC]
      - getOnlyImpliedSquareBoardRules 4 16 [PC] (goes to 4,75)
      - getOnlyImpliedSquareBoardRules 4 17 [PC]
      - getOnlyImpliedSquareBoardRules 4 18 [PC]
      - getOnlyImpliedSquareBoardRules 4 19 [PC]
      - getOnlyImpliedSquareBoardRules 4 20 [PC]
      - getOnlyImpliedSquareBoardRules 4 21 [PC]
      - getOnlyImpliedSquareBoardRules 4 22 [PC]
    - Future:
      - Highlander on smaller boards(!)
  - 
  - Build failure, trying `npm run build --max-old-space-size`
    - export NODE_OPTIONS=--max-old-space-size=32768
    - Maybe we should... ditch loading all the data? (remove references for the collections tests?)
  - 
  - MINISAT FAILURE
    - getImpliedGeneralBoardRules 2 47 [PC] <<<<------- WAIT WAIT we have.... minisat FAILULRE
    - 2 48 also
    - minisat-OUT
    - Perhaps we are giving it too many loops?
    - CONSIDER:
      - What if we... manually compute these? For these SMALL cases, it is probably practical
  - 
  - [LinCb0!!!] General performance enhancements:
    - [First, testing infrastructure] ADD IN TESTING TO ENSURE GENERATION IS STABLE!!!
      - Then have a way to UNIT TEST to see if our rule generations are EQUAL to what is there.
    - See pruning discussion with ChatGPT
      - [implement LinCb0] - from https://arxiv.org/pdf/2011.04928, etc.
        - Looks important for e.g. getImpliedColorSquareBoardRules 2 4, which is going up to 47k implications 
      - [implement pruning] from the paper
      - We can see if implications would be VIOLATED by adding an attribute (early termination)
      - OMG OMG - treat implications maybe differently if they "imply everything" (invalid)
        - Still keep those in our implications,
        - Consider showing how many non-to-invalid implications we have in our set (in our debugging info)
    - Performance test best way to handle bit vectors - 110 bits seems slow?
    - CONSIDER reordering of attributes or objects!!!!
      - [NO] START WITH OBJECTS WITH SMALLER INTENTS, OR ONES THAT INTERSECT WITH MANY OTHER OBJECTS INTENTS
        - Wait, what would this do...?
      - [probably not - only after adding pruning] REORDER ATTRIBUTES?
  - 
  - Improved highlander:
    - [first] Store whether a rule/pattern is highlander(!), it should be serialized?
    - 
    - Bloom filter "deduplications"?
    - 
    - For now, bitsets
      - Non-exit edges: 1,0 for red, 0,1 for black
      - Exit edges: 1,0 for hard-red, 0,1 for black, 1,1 for red-or-double-black
      -  
      - edgeHighlanderCode
      - Map<bigint, SolutionAttributeSet | null>, first goes to the set, then null when a duplicate is found
      - Indeterminate (non-exit) edges get both bits set in the mask
      - No-feature exit edges get all of the bits set in the mask
      - Red-exit-edge gets none of the bits set in the mask???
    - 
    - Currently it is NOT working with blank exit faces - notably exits that could be "double black"
    - Even though exit face edges can potentially be determinate, the exit has three cases:
      - For each solution, an exit edge is:
        - (a) potentially red (solution has no edges through exit vertex)
        - (b) single-black (solution has one edge to the exit vertex, and it exits as a connection)
        - (c) HARD red (solution has two edges through the exit vertex)
      - Just like our "if the indeterminate edges are the same, it is filtered out", this information needs to be included
        - Solutions with the same exit "states" can be filtered out
        - *** Adding red exit edge as a feature CHANGES this
      - Current plan is to ADJUST the "simple (non-implication) closure" to filter highlander duplicates out, since we might add exit edge (red) features
    - 
    - Highlander ON COLORS? (figure this out)
      - Or maybe... match face values of exit faces?
      - Can we... perhaps match whether "exit faces" are ... null? (because then we could get more indeterminate edges)
        - Yes, if we expand this to pattern matching with blank exit faces, we'll be able to detect a TON of patterns
          - !!!!!! (1,0) will get us the main pattern, instead of (4,?)
        - Exit face (opposite a face WITH a numeric/null value, not ?) is a candidate to have a non-indeterminate edge
  - 
  - Image output robustness: if a ruleset has more than N rules, split it up into chunks!
  - 
  - FIX NAMING eventually, 'general-implied' should be 'general-edge-implied'?
  - 
  - "all" feature set - how to check to see if faces IMPLY edges, and vice versa?
  - 
  - Serialize individual rules, for "collections"
  - 
  - Check if implied is using isCanonicalWith (we might want to only use canonical rules, should be guaranteed to have them, no?)
    - Maybe not?
  - 
  - [meh, we don't have huge amounts of implications] HEY! getEmbeddedRules might be giving us some "duplicates". I think we were filtering these out before
    - Filter these out where possible, so we're not doing more computation? 
  - 
  - FeatureSet "only one" is... weird to store. It is essentially true if not-zero and not-two (redundant)
  - 
  - Test implied-highlander (... to check our GOOD case, we need all of level-3 square, and the specific level-4 square)
  - 
  - WebGPU general-purpose FCA "solver"
    - NOTE: multiple approaches
      - (a) do the "parallel" full approach suggested by that paper. how would we handle the massive amount of memory?
      - (b) do the next-closure, BUT parallelize the parts (both checking multiple i's, AND parallel-apply of SolutionFormalContext.getClosure/Implication.implicationSetClosure)
  - 
  - Fix up generation (we broke some things?)
  - 
  - Clean up all SORTS of code. See if FCA approach is widely better in all ways.
  - 
  - TPatternBoard cleanup:
    - 
    - !!!!!! GET RID OF TPatternBoard, just make BasePatternBoard => PatternBoard.
      - Then we can store PatternBoard-related info (e.g. automorphisms, planar mappings, bit-packing metadata) on it
    - 
    - default planar mapping on TPatternBoard
    - 
    - QUICK:
      - Make a "pattern-boards" page that shows pattern boards
        - ESTABLISH a registry of "tiling" types
    - Description and mapping on TPatternBoard(!)
      - Registry of simplest-mapping pattern boards (based on isomorphism)
        - We attach the rules to these
  - 
  - Symmetry pruning
    - Store stacks of choices. Can evaluate whether it is canonical.
    - NOTE: We can calculate AT WHAT stack index we should potentially check for WHAT automorphism!!!
      - Of course, ignore identity automorphism 
      - What if the pattern is equal when the automorphism is applied? (then we will rely on the "filter" later to remove it)
  - 
  - Make a good "viewer" for patterns/rules (ideally one we can scroll through though)
  - 
  - Rules Solver!
    - (for plugging into the UI, puzzle generation, difficulty estimation(!))
    - Performance: PatternRule.withRulesApplied
      - Looks so much like [LinClosure] noted from LinCbO paper.
      - 
      - Make sure to combine embedded rules that have the same embedded input feature set 
      - 
      - PatternRuleApplicator (keep finding matching rules, apply them, then wait for more)
        - PatternRule.isRedundant will:
          - (a) scan for what parts of the rule are "missing" (edges, sectors, faces/duals?)
          - (b) if missing, start an applicator
            - it will find a match, and apply it, then return back to us (noting WHAT CHANGED)
            - we see if we are redundant yet, if not, continue until NO MORE MATCHES
        - Applicator will:
          - Store arrays for (edges, sectors, faces/duals?) that get rules with "those parts missing"
            - Whenever we apply a rule that hits these, we put them "back in the queue"
            - Obviously we ditch rules that can't be applied (incompatible OR not face values)
        - duals for "missing" - can be noted by their canonical string (so we can easily match/remove)
        - 
        - NOTE!!!!!! : For redundancy, we know that rules that are INCONSISTENT with our "output" will never be applied
      - 
      - Rule search tree for fast solving?
      - Dirty rules:
        - Store "dormant" rules with <needs feature> for faster solving
        - Basically "don't keep trying to match rules when we haven't changed any of their input features"
      - ... we could just BAKE the "no simple loops" thing into our rules, with potentially faster checks?
        - Would this reduce the number of rules?
          - !!!!!!!#$!#$!#$
          - #$!#$!#$
          - Yes just include this condition in the "redundancy" check solve
      - Is there a pre-sorting or pre-processing of rules that could be done to make this faster? (besides collapsing)
  - 
  - Face colors!
    - !! How to collapse face color rules nicely? (from exit vertex to... non-exit?)
    - Add the "color matching" so the pattern rules are more... viewable?
  - 
  - "initial feature set" for PatternRule.getSolutionEnumeratedRules (for "only")
    - e.g. "red exit edges" for vertices for square/hex patterns ("only")
    - remove faces/edges from the list at start time?
      - remove face color dual combinations that are incompatible at start time?
    - [ready to go, should allow squareOnly/hexOnly searches to be faster]
    - NOTE: For face coloring, we'd really want ... multiple initial feature sets (permutations?)
      - Imagine 3 squares diagonal pattern. Yes red exit vertices (2), BUT we can't just FIX face colors, because multiple embeddings(!)
  - 
  - WHEN WE SHOW EMBEDDED VERSIONS, execute MULTIPLE PatternRules on the "simpler" embedded version
    - Certain topology (red exit vertex, etc.) features will probably unlock more things
  - Also when we show embedded versions:
    - We have a lot of rules for "preventing simple loops" or "preventing simple loops after we do something trivial"
  - Hex 1-0 has tons of these... anything with an exit vertex on the connection is... essentially not a rule
  - 
  - Check code TODOs
  - 
  - Rule collapse on embedding too (consolidate)
    - (do this in places where we are ... solving?)
  - 
  - Testing
    - SolutionSet unit tests
    - Rule set fuzzing (ensure "random feature set" that is valid is properly solved by our rules)
  - 
  - Highlander with FACE COLORS (!)
  - 
  - Parallel running:
    - https://github.com/deThread/dethread?tab=readme-ov-file / https://socket.io/docs/v4/
  - 
  - FeatureSet.difference (things we can apply, essentially the pattern rule output)
    - (performance, but also "hey we can show what actually changed")
    - Also, our matching is partially based on this(!)
  - 
  - Highlander canonical:
    - For each solution, we can extract out the string for its (a) indeterminate edges, and (b) exit connections in a canonical form
      - Easily allows searching for highlander-duplicates
  - [ HEY HEY!!!! ]
    - Let's just output both FeatureSets of non-highlander AND highlander (from the solve process)
  - 
  - Matching!!!
    - !!! Match exit edges (red) with either absence or just red edges. no white/black!
    - ... Almost everything else needs to have an exact analogue? (sectors, face colors, non-exit edge features, etc.)
  - 
  - !!! For feature equality (of a list that is nonredundant) - just get canonical strings, sort, append, compare!
    - NOTE: We can't exactly deduplicate embeddings with this, due to FACE COLOR DUALS that start to "overlap"
      - HEY, for embeddings, COMBINE FACE COLOR DUALS that have overlap(!)
        - embedFeatures( features ) => features, handles overlapping things (face color duals) and removes redundancies
          - then sort to "canonical order"?
  - 
  - View for pattern - canonicalize which face features get which coloring (lowest index ordering) so those don't... change? hmm awkward
    - We... actually want to try to keep face colors consistent? (allow passing in a previous mapping?)
  - 
  - !!!! When we have a set of features we are adding, we can potentially RULE OUT other features (intelligent exploration)
    - e.g. pick face color features. we can then use the solver to enumerate all solutions, and RULE OUT other features that are not present in any solution
  - 
  - [NOTE: not a bottleneck for patterns] Can we use Solver.solveAssuming
  - 
  - NOTE: Handle FaceColorDualFeature differently, no redundancy checking
  - 
  - Face Color Annoyance:
    - DO SMART FACE COLOR DUAL features? (not... named?)
      - Storing duals means:
        - (1) FASTER matching (since we don't do O(n^2) checks for large regions)
        - (2) Can provide the exhaustive O(n^2) for computing all solutions and analyzing
        - (3) our "output" state change can be a "list of the face color actions needed to be done"
    - Our booleans are VERY over-specified. Are dual-color with faces representations possible?
      - (though this is... so simple)
      - HEY this causes our logic-solver to get a LOT of complicated rules that it probably doesn't need(!), O(n^2)
        - O(n^2)!!!!!!!!!!!!! 
      - Could just be consistent and compute duals, and:
        - (a) fully specify all color relations based on the relationships (fill them out)
        - (b) minimize them when we actually... scan for patterns?
  - 
  - "Constraints" vs "Features"
    - Constraints: We add constraints at the start of solving, and they don't change
      - (can use Feature interface for adding solving constraints) 
      - Highlander
      - [defer] Nonzero-crossing (NEW: 2+ crossing) - both could be used in the future
      - [defer] NEW: certain exit vertices NEED to connect together? Or need NOT to?
      - Vertex 0-or-2 rules
      - Face values (including blank)
    - Features:
      - .. All the other things we are used to
  - 
  - Highlander:
    - Q: Do we need to iterate through all solutions for highlander?
      - Can "hash" highlander solutions by:
        - (a) string of booleans (one per indeterminate edge)
        - (b) lexicographically ordered "exit vertex (or edge) index pairs that are connected", e.g. 0-5, 2-3, etc. (exit vertex 0 connects to exit vertex 5)
    - Edges that are adjacent to an exit-face OR non-valued (non-blank) face are "indeterminate" edges (exit edges are indeterminate)
    - Two solutions with the same values on indeterminate edges AND same exit connections are both excluded in highlander rules
    - NOTE(!) Highlander rules might NOT require blank faces (especially once sectors and colors are in play)
      - (we will have highlander color rules)
    - How to mark/display these? question marks on unspecified faces?
  - 
  - Storage/Serialization of patternboards / patterns / rules
    - PatternBoard
      - Naming prefixes? square, "4x4" for "there are four 4-order faces"? not sure how we would disambiguate
        - Actually, fixed strings for the "edge/vertex" ones, and... STORE the face indices in a string for the face ones?
    - We want to consolidate references to PatternBoards, so that the embeddings computation is "spread across all the rules"
    - Wait, CAN WE skip storing the mappings, since we can just find embeddings in tilings and report those out?
      - But... we should determine isomorphic pattern boards... take in strings and cache isomorphic ones?
        - Would we need to "remap" patterns/rules?
  - 
  - PatternEmbeddingNode - PatternBoard in PatternBoard (without state at first)
  - 
  - Pattern = pattern-board + pattern-state (features?)
    - Face values are part of the pattern/features, no? 
    - How to think of highlander?
  - 
  - [defer] Nonzero (or 2+) crossing type - compute possible paths
  - 
  - !!!!!!!!!
  - !!! Find all embeddings of a specific (shared) patternboard in a board-pattern-board
  - !!!!! THEN GET the "current features/state" of it (from the board+puzzle=state) => "featured board" so we can scan efficiently
  - !!! (extract features from board+state, into a featured board)
  - !!!!!!!!!
  - We do NOT apply "black exit edges" with the pattern, or exit sectors, etc. Keep things simpler, rely in "larger" patterns for those
  - Vertex topology updates to be... like there are "face portions" and non-face portions
    - [no] WAIT, are most "vertex" rules... really "face" rules???
      - NO NO, we really DO have vertex topology setups 
  - [ignore, we will not infer in invalid puzzle] How to "pattern match" an "exit edge" if it will contain... 2 black? (patterns will not really apply well)

- We are able to apply patterns without OR WITH the "topological simplification"(!)
  - Ooo, this might be good for generating puzzles?

- Assume patterns/rules only applied if they don't include the entire solution (can't be the loop, loops prevented)

[API needs to be compatible with boards, maybe with adapter]
  - Can we put an 'index' on everything in a board?

- [defer] "Invalidity" patterns?

- Running through all SAT solutions is possible, but can do better
  - First, do pre-checks (quick) to see if the pattern is clearly impossible 
  - Keep a running list of loops (that will always be negated)
  - FIRST find a no-added-constraint no-loop solution
    - IF none, then the pattern won't occur in a valid puzzle
  - If a no-loop solution is found, mark all of the POSSIBLE things immediately.
  - After we have one solution, we can:
    - Find a NOT_FOUND boolean, restart with a constraint that it must be possible, and see if we can find a solution:
      - If we can't, mark it IMPOSSIBLE
      - If we can, do the normal "mark POSSIBLE" things and start again with another NOT_FOUND BOOLEAN
    - NOTE: Might be more efficient to run through a fixed (N=10) number of solutions, to get more possible bits?

- Exit edge decisions:
  - Ignore "black" exit edges (no feature for that both for input and output).
  - No sectors for exit edges (no feature for that both for input and output).

- PatternBoard:
  - [defer] Generation: 
    - [defer] Prevent combinations where... a face isn't included but all of its neighbors are? (or perhaps... if all its vertices are included, include it?) THINK
  - [defer] Canonicalize:
    - [defer] Find the vertex permutation that gives us the lexicographically smallest order of states.
    - [defer] Then we can use equality to check isomorphism (and we can store this in a hash table)

https://github.com/timhutton/slinker ---> has the "solving rules"
Review https://github.com/timhutton/slinker/blob/main/src/SlinkerGrid.cpp !!!!

[this is mostly old, refresh it]:

- Topology-invariance (full):
  - Make a pattern. Can "add" topo-invariant things to it with a match.
  - 
  - Same as our topological bit, BUT REVERSE the simplification when matching?
  - RED edges mostly disappear or no?
  - IF we deal with a single part of a face, we can "generalize" the rest of the face?
  - RED EDGES essentially CHANGES the topology
    - Make rules that can be applied to ANY cases 

[Deprecated]

- [deprecated - use implication search] "Solution Search" Performance wins:
  - (!!!!!!!!) - What if we do a BFS-like search (but keeping canonical at each step?)
    - This gets us "instant incremental"
    - WOULD NEED TO BRING BACK THAT "DUAL"
    - ---- wait, won't this take up a LOT of memory? (!)
  - (!!!) WE can use "output feature sets" / solution sets to ACCELERATE the search?
    - If we have said feature sets A => B, then it makes no sense testing anything between A and B
    - WAIT think about this (recall, if we are going for MINIMAL, there might be A* with a different feature that is minimal)
      - And thus we can't just "skip" to B
        - (!!!) WAIT, but we CAN just "delay" those features, and focus on others (since exploring them will give no info)
          - (!!!!!!!)
            - Can we "choose" features to select, based on their frequency?
              - Will splitting with a more "binary" search be more efficient?
              - CAN WE INITIALLY ORDER FEATURES so that the isomorphism checks can prune large amounts?
                - ... e.g. start with unique "corners", if we have set all N of what it can map to, we can
                  - START SYMMETRY PRUNING.
                - (obviously, don't do this on boards with only the identity isomorphism)
    - BUT BUT we can just... do a "quick check" when it's time to decide a feature, see if it can only take one path(!)
      - This is almost... like a "skip"
  - (!) OMG keep the rule that we "branched" from, and see if it directly solves the next one (with a single feature added)
    - Possibly with a tiny subset of features?
  - (x) Don't use that "stack", just pass parameters?
  - (a) minimize amount of new objects created for each SolutionFeatureSet
    - can we store just a "row index" of the solutions? lightweight view
    - can we store just a "new feature" list? Why are we... doing FeatureSets? ---- OMG why are we storing FeatureSets?
  - (c) potentially prune automorphisms EARLIER!
    - We could at least do automorphism/canonical checks AT END OF FACES(!)
- [deprecated, solved by implication search] 3-face colors running into... generateAllDisjointNonSingleSubsets blowing UP!!!
  - ... do we just make this more of a callback iterator (or generator)?
- [deprecated, just use implication search] Performance: PatternRule.getSolutionEnumeratedRules
  - Can we filter "satisfied" previous rules out?
    - This requires more expensive checks. Could see if a rule's outputFeatureSet has our change (and only check then)
    - If rule.outputFeatureSet.isSubsetOf( ... featureSet ) <--- requires computing featureSet?