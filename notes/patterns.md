
# Patterns

- TODO
  -
  - Note https://puzzleparasite.blogspot.com/2011/11/slitherlink-pattern-guide_23.html in solving guide
  - 
  - Improvements:
    - Pattern SOLVE in difficulty(!)
      - Levels?
        - ... depends on colors / sectors or not?
    - Rule colors: sync them!
      - Fix a seed of random numbers, so we can reproduce the same face coloring (particularly for showing patterns)
  - 
  - LOADING message for play / rule explorer / rule
  - 
  - Bugs:
    - Assertion failures in rule-explorer (!!!!) - especially swapping to/from color
      - Once resolved, do the "don't show sectors" bit?
  - 
  - Performance:
    - PuzzleNode perf
      - FaceStateNode lazy creation
      - OMG share listeners, so we don't create so many for PuzzleNode?
  - 
  - rule-explorer.html
    - Better than pagination -- infinite scroll?
    - Perf: potentially reuse PuzzleNode, but with a new state (if they have the same pattern board)
  - 
  - Image output to a static form?
    - Every 2 bytes in an SVG image is (!) 1MB of rule images(!!!!!) --- we have half a million rules
  - 
  - ZOMG ZOMG ZOMG ZOMG OMZG OMZOGMZOGMOSMGOSRIMGOSIMRGOSIRMGOSIMRGOSIRMGOSGIMROSIMRG
  - ------------------
  - PatternRule TRUE INCIDENCE
    - Generate "uniform" puzzles (TRULY UNIFORMLY?)
    - Then examine how many of the unique embeddings MATCH (check embedding equality!) across many puzzles!!!
    - Can we... categorize "usefulness" or how common it is for a pattern?
      - NOTE: Symmetry arguments probably help (if it has more automorphisms... it is more likely to be useful)
  - SOLVING INCIDENCE
    - As we are solving a puzzle, how often does a rule come up?
      - Clearly changes with rankings? - but we can also note how often a rule sits unused? THINK
  - 
  - Embeddings taking up 44MB, lets switch to index arrays (instead of maps). Compact and fast, since we have contiguous indices, right? (maps ALL of something)
    - Embeddings be index-based (we can still reproduce the effects of the maps)
      - Sounds great. Have edge indices map to edge index OR array index (based on whether it is an exit)
      - We should CHANGE the code that computes embeddings(!)
  - 
  - Pattern solvers are NOT checking to see if they could be the entire closed loop. FIX THAT.
  - 
  - BoardPatternBoard ... memoize?
    - Do we do the matching in pattern space or original state space?
      - (a) create FeatureSet from state, match there (with normal matching functions)
        - Preferred, less code? BUT [WE NEED TO MATCH WITHOUT CREATING EMBEDDED VERSIONS?]
      - (b) Match directly into the state, through an adapter
  - 
  - [!!!] Pattern smaller than pseudo-intent - are there UNIQUE reductions (even if not complete) that we can make?
    - The Duquenne-Guigues basis is only great for "include all of the rules" (or at least the subset*)
    - We probably already have generated ALL (or almost all) of the rules we will actually want.
    - Is this... essentially a unique infimum?
    - [!!!] NOTE: we only need this to be unique TO ISOMORPHISM
  - 
  - Pattern Solver:
    - FinClosure, once we have all embedded?
  - 
  - [important, big] Highlander implies BLACK EXIT EDGE PATTERNS - we have based things off of the wrong patterns.
    - THIS might need edges not connected to faces? More general
  - 
  - Highlander + color:
    - Essentially a "red exit edge" is where the color is forced to be the same for the entire exit
    - This seems "solvable" in the "ALL" solving stage?
  -  
  - FeatureSet improvements:
    - "all" feature set - how to check to see if faces IMPLY edges, and vice versa?
    - Sector only-one is... internally redundant (see the BINARY forms)
  - 
  - getSolutionImpliedRules embeddedRules
    - duplicated "embedded" rules might reduce memory
    - [action] console.log embeddedRules length, see if it is getting out of hand? Is that what is causing crashes?
  - 
  - TPatternBoard cleanup:
    - !!!!!! GET RID OF TPatternBoard, just make BasePatternBoard => PatternBoard.
      - Then we can store PatternBoard-related info (e.g. automorphisms, planar mappings, bit-packing metadata) on it
        - WeakMaps of embeddings on each PatternBoard?
    - default planar mapping on TPatternBoard
  - 
  - Apply patterns with "topological simplification"(!)
  - 
  - Check code TODOs
  - 
  - !!! For feature equality (of a list that is nonredundant) - just get canonical strings, sort, append, compare!
    - NOTE: We can't exactly deduplicate embeddings with this, due to FACE COLOR DUALS that start to "overlap"
      - HEY, for embeddings, COMBINE FACE COLOR DUALS that have overlap(!)
        - embedFeatures( features ) => features, handles overlapping things (face color duals) and removes redundancies
          - then sort to "canonical order"?
  - 
  - View for pattern - canonicalize which face features get which coloring (lowest index ordering) so those don't... change? hmm awkward
    - We... actually want to try to keep face colors consistent? (allow passing in a previous mapping?)
  - 
  - !!!! When we have a set of features we are adding, we can potentially RULE OUT other features (intelligent exploration)
    - e.g. pick face color features. we can then use the solver to enumerate all solutions, and RULE OUT other features that are not present in any solution
  - 
  - Face Color Annoyance:
    - DO SMART FACE COLOR DUAL features? (not... named?)
      - Storing duals means:
        - (1) FASTER matching (since we don't do O(n^2) checks for large regions)
        - (2) Can provide the exhaustive O(n^2) for computing all solutions and analyzing
        - (3) our "output" state change can be a "list of the face color actions needed to be done"
    - Our booleans are VERY over-specified. Are dual-color with faces representations possible?
      - (though this is... so simple)
      - HEY this causes our logic-solver to get a LOT of complicated rules that it probably doesn't need(!), O(n^2)
        - O(n^2)!!!!!!!!!!!!! 
      - Could just be consistent and compute duals, and:
        - (a) fully specify all color relations based on the relationships (fill them out)
        - (b) minimize them when we actually... scan for patterns?
  - 
  - [defer] Embedded rules issues
    - "trivial / isomorphic when embedded"
    - "collapse when embedded" - e.g. incomplete rule
    - 
    - WHEN WE SHOW EMBEDDED VERSIONS, execute MULTIPLE PatternRules on the "simpler" embedded version
      - Certain topology (red exit vertex, etc.) features will probably unlock more things
    - Also when we show embedded versions:
      - We have a lot of rules for "preventing simple loops" or "preventing simple loops after we do something trivial"
    - Hex 1-0 has tons of these... anything with an exit vertex on the connection is... essentially not a rule
    - Rule collapse on embedding too (consolidate)
      - (do this in places where we are ... solving?)
  - [defer] "Constraints" vs "Features"
    - Constraints: We add constraints at the start of solving, and they don't change
      - (can use Feature interface for adding solving constraints) 
      - Highlander
      - [defer] Nonzero-crossing (NEW: 2+ crossing) - both could be used in the future
      - [defer] NEW: certain exit vertices NEED to connect together? Or need NOT to?
      - Vertex 0-or-2 rules
      - Face values (including blank)
      - [defer] - we can solve based on vertex connection info, could this be a constraint in the future?
    - Features:
      - .. All the other things we are used to
  - [defer] FeatureSet.difference (things we can apply, essentially the pattern rule output)
    - (performance, but also "hey we can show what actually changed")
    - Also, our matching is partially based on this(!)
  - [defer] Nonzero (or 2+) crossing type - compute possible paths
  - [defer] Rule reduction using BinaryPatternSolver-like handling (apply rules)
    - PatternRule.withRulesApplied with BinaryRuleCollection(!)
      - WE NEED a "bail out condition" (like, either if FULLY SOLVED, or if when checking redundancy "we reached our pattern")
      - BinaryRuleCollection.matchXXX( targetFeatureSet, embedding, ruleIndex )
  - [defer] "Invalidity" patterns
  - [defer] Faster SAT enumeration
    - Running through all SAT solutions is possible, but can do better
      - First, do pre-checks (quick) to see if the pattern is clearly impossible 
      - Keep a running list of loops (that will always be negated)
      - FIRST find a no-added-constraint no-loop solution
        - IF none, then the pattern won't occur in a valid puzzle
      - If a no-loop solution is found, mark all of the POSSIBLE things immediately.
      - After we have one solution, we can:
        - Find a NOT_FOUND boolean, restart with a constraint that it must be possible, and see if we can find a solution:
          - If we can't, mark it IMPOSSIBLE
          - If we can, do the normal "mark POSSIBLE" things and start again with another NOT_FOUND BOOLEAN
        - NOTE: Might be more efficient to run through a fixed (N=10) number of solutions, to get more possible bits?
  - [defer] PatternBoard Generation: 
    - [defer] Prevent combinations where... a face isn't included but all of its neighbors are? (or perhaps... if all its vertices are included, include it?) THINK
  - [defer] PatternBoard Canonicalize:
    - [defer] Find the vertex permutation that gives us the lexicographically smallest order of states.
    - [defer] Then we can use equality to check isomorphism (and we can store this in a hash table)
  - [defer] Performance: PatternRule.withRulesApplied
    - Looks so much like [LinClosure] noted from LinCbO paper.
    - 
    - Make sure to combine embedded rules that have the same embedded input feature set 
    - 
    - PatternRuleApplicator (keep finding matching rules, apply them, then wait for more)
      - PatternRule.isRedundant will:
        - (a) scan for what parts of the rule are "missing" (edges, sectors, faces/duals?)
        - (b) if missing, start an applicator
          - it will find a match, and apply it, then return back to us (noting WHAT CHANGED)
          - we see if we are redundant yet, if not, continue until NO MORE MATCHES
      - Applicator will:
        - Store arrays for (edges, sectors, faces/duals?) that get rules with "those parts missing"
          - Whenever we apply a rule that hits these, we put them "back in the queue"
          - Obviously we ditch rules that can't be applied (incompatible OR not face values)
      - duals for "missing" - can be noted by their canonical string (so we can easily match/remove)
      - 
      - NOTE!!!!!! : For redundancy, we know that rules that are INCONSISTENT with our "output" will never be applied
    - 
    - Rule search tree for fast solving?
    - Dirty rules:
      - Store "dormant" rules with <needs feature> for faster solving
      - Basically "don't keep trying to match rules when we haven't changed any of their input features"
    - ... we could just BAKE the "no simple loops" thing into our rules, with potentially faster checks?
      - Would this reduce the number of rules?
        - !!!!!!!#$!#$!#$
        - #$!#$!#$
        - Yes just include this condition in the "redundancy" check solve
    - Is there a pre-sorting or pre-processing of rules that could be done to make this faster? (besides collapsing)
  - 

https://github.com/timhutton/slinker ---> has the "solving rules"
Review https://github.com/timhutton/slinker/blob/main/src/SlinkerGrid.cpp !!!!

[this is mostly old, refresh it]:

- Topology-invariance (full):
  - Make a pattern. Can "add" topo-invariant things to it with a match.
  - 
  - Same as our topological bit, BUT REVERSE the simplification when matching?
  - RED edges mostly disappear or no?
  - IF we deal with a single part of a face, we can "generalize" the rest of the face?
  - RED EDGES essentially CHANGES the topology
    - Make rules that can be applied to ANY cases 
