
- PhET bugginess:
  - How to get text entry (DOM node?) - can we focus it on detecting a click? NO we NEED to pass events through
  - RichText broken somehow... with rollup?
  - Get CAG fixed, using Alpenglow's robust option
    - Get alpenglow into a usable state in phet-lib

- Current code TODOs
  - Actions for face color changes... should potentially specify the faces? Bleh not sure, is tricky how to serialize
    - If they don't... the face color IDs might change.
  - Reloading on completed puzzle... seems to "error out"? Check (it is wiping our state)
  - TRACK DOWN face color (parity?) bug, see double-5 in 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
  - Autosolver should always go "until error detected" (whether our input is valid or not)
    - Just use the validator when we "should" have no errors?
  - If the user changes a non-white edge (ignoring the quick-undo for double tap), we should reset all state except edges (and face values)
    - Create "reset" handlers for each data type
    - Create a global "reset" method to reset all existing state (add to TState?)
  - Serialization of actions.... is a mess. Clean up, so we can serialize them and the stack (undo possible after reload)
  - High Contrast themes
    - Hard to see colors at night on phone
  - Switch to ABSwitches (toggle switches) for configurations
    - https://blog.uxtweak.com/checkbox-vs-toggle-switch/ notes they are for "immediate effect" - which they are, checkboxes are delayed effect
  - Move more parts of files out to the top level (hard to find things!)
  - Immediate error detection when a mistake is made (also NOTICE if the auto-solver fucks up independently from the user)
  - Unit tests and fuzzing for solvers (generate a puzzle, then apply the full solver. when it stops, give it another edge)
    - ANY TIME IT GIVES SOMETHING INVALID FOR THE FINAL SOLUTION(!) notice
    - Can also check to see whether there is a bug in the "dirty" handling - fresh solver shouldn't solve anything additional
  - TPuzzle improvements (Property is awkward)
  - Rename FaceData => FaceValueData, FaceState => FaceValue?
  - TaggedAction - noting the "required" parts of the pattern, and noting the "changes"
    - So that if we encounter a buggy thing, we can see what it was trying to do
  - HINT button (highlight the thing the next rule would change?)
    - OMG LIGHT THE BUTTON UP AS ENABLED WHEN WE HAVE A HINT
  - Highlight region of "dual color + opposite" on hover?
  - Generation / difficulty [see generation.md]
  - Stronger "white lines" when using face colors?(?) - how to handle UI
  - View modes?
    - Separate toggles for various features? (face color in particular?)
    - Color faces (with uncolored edges?)
      - THIS COULD LOOK COOL!!!
    - Color edges (with only critical faces colored?)
  - Edit modes
    - Edge edit mode (default) 
    - Face link mode (to handle coloring) - different from edge edit mode
      - Or a mode for "edit face values" (and a generate-blank option in generation) to edit a puzzle?
  - Solver that detects "single vertex not-biconnected" cases and prunes
  - Solver that looks at adjacent colors (if we're adjacent to a color and its opposite, it affects the face/vertex/ state)
  - Solver for colors around face states (e.g. spiked 2s)
  - Face Coloring UI
    - Face coloring by value (monochrome?) - give speckled pattern for blank board
      - Slight background color change for each cell (for tilings), based on ... the tactile-js coloring?
        - NO, just use our force-directed style
    - Consider a texture for "inside" and "outside"
    - Allow manual face coloring ... would "drag from one face to another" work? (PAN/ZOOM messed up by that?)
      - Solvers: 
        - OMG --- the mediumfacesolver bit... should work nicely for any geometry? figure out the math 
        - Touching combinations of colors?
        - Ensure I have everything ported from my Scala code regards to solvers, e.g. "MediumFaceColorSolver?" - examine face and coloring around it
  - Face Coloring Solving
    - Watch https://www.youtube.com/watch?v=PLdZwjs3mzQ to see if there are good tips, also https://www.youtube.com/watch?v=FU_xW8n-jzo
  - SHOW the vision working on the image(!)
  - Code cleanup
    - Clean up BasicSquarePuzzle too? Move it to BasicPuzzle?
    - TPuzzle shouldn't have Property... that should be TMutablePuzzle?
      - Maybe just have a TPuzzleProperty? (hmmm) bleh
    - Have TEdge mimic BaseEdge's API, etc. (they define the interface)
  - Settings
    - "Control Center" style
      - Provide quick high-level on-off (ABSwitch?), with "more..." to control details
        - Auto-solver on/off
        - Face coloring on/off
        - ...?
    - Separate appearance from auto-solver settings 
      - Tabs? (from joist? eek)
    - Style preview (demo puzzle)
      - Include animation previews(!) 
  - Improve "line segment ending" and vertex shapes! Give options
    - include white edges and region edges?
  - Bugs
    - Auto rules don't seem to be... working on some of the shape sizes...? (31 in particular?)
  - Aesthetics:
    - Finished appearance: improve somehow?
  - Interface:
    - Possibilities
      - SLICK animation(!)
        - Use Twixt damped animation! 
        - Animate transitions to generation / puzzle start / puzzle end (TransitionNode?)
        - Can we make it more intuitive by having the line animate?
        - Option for no animation, or animation speed
      - Buttons 
        - Add default option that hides "undo-all" and "redo-all" (can be enabled) - don't tend to use them much 
        - RAINBOW COLORS on the buttons
        - Hint button (maybe "add a face value")
        - Zoom (in/out) for help on desktop (e.g. with mouse)
          - Show these only if the control bar is large enough!!
        - Solve button (solve everything as one action, or solve but put each step on stack, OR solve just one action)
          - Will apply "history" state for EACH solve step
          - OR WILL APPLY IT AS ONE THING ---- we might want each
        - Share/export button
          - Puzzle text (faces, faces/edges, in different formats)
          - Image (hey... can we use Alpenglow for the high-quality bits?)
        - Mark/save (for user "exploration")
          - Show "history display" so the forward/backward/ undo/redo/etc. make sense, ESPECIALLY once we have mark
      - Possibly multiple views (one coloring, one vertex?)
        - Or keypress to "view how many remaining" on a face? --- have a momentary button for this in interface?
      - Vertex coloring (e.g. spikes/incident, but also "all of the cases")
      - Loop (around square parity), but also maybe a "loop tool" where if you draw it, it will count automatically.
      - Area coloring (with specific known-inside or known-outside coloring, but also color other multiple-square areas)
        - blue/yellow (from the path tracing demo) for inside/outside default? 
        - ACTUALLY shades of gray? if we are coloring lines. we don't want too much color overload
        - DO MOUSE OVER?
        - Would it... be REALLY pretty to average colors out?
      - Color face values by the number of edges on the face? (a 2-of-3 is different than 2-of-4) - only relevant for certain patterns
      - Line coloring: highlight endpoints/line when over it? (like make the endpoints NOTABLE in case of color similarity)
      - Add config for press styles (but also figure out other input methods - e.g. dragging multiple lines)
        - Hey, how would dragging multiple lines work with pan? EXCLUSIVE SETTING
        - What about "quick double press" for x?
      - If RED on all 4 of a vertex, perhaps we can remove vertex dot?
      - Have PatternExplainers that we can display to show what we can deduce next
      - Have a "solve a single bit" button
      - Allow finger drag to put down multiple lines? (can we reverse back through a line to undo parts?) 
      - IDEALLY we should have a good way for "touch" to input Xs. Maybe a "shift"-equivalent button? 
        - An "inverse" or "X" sticky button at the top? 
      - Vertex interaction (note incident or spike? - or any of possible vertex states?)
        - Allow a "mark save point" (that can be jumped back to)
  - Share URL size:
    - Store "board generation string" on a TBoard
      - Consists generally of "which generator" + "which parameters", but also our scanner will need to output (e.g. square?)
      - Have a specification for this!
    - When we have that, store faces as a simple string (and compress)
      - Also, edges in order, can specify edge state IN A SIMILAR MANNER
    - MINIMIZE the format of boards (so we can stuff custom-boards into fairly short URLs) 
  - import format from https://www.kakuro-online.com/slitherlink/
  - import allow paste of image, https://web.dev/patterns/clipboard/paste-images
  - Rule display (in UI), so we can have a good example of "just display some state" (without input), but potentially allowing animation?
  - Google Analytics (and fix for site? GA4?)
  - Immutable views
    - Would be great for an "explainer" page (this would be fun to write up)
  - Mobile issues:
    - HANDLE the annoyance that is "trying to tap multiple things" while auto-solve is active (and messes with the 2nd action)
    - Don't allow panning outside of the "region" (can go far to left/right on vertical puzzle)
    - Autosolve annoyance on mobile:
      - Prevent user from changing auto-solved edges immediately (?)
      - Autosolve Delay? - (allow for putting in multiple things (e.g. multiple lines) or switching to Xs?)
        - Presumably after a delay, replace the current stack state (with action and simple change) with an autosolved change
        - TAG stack transitions (puzzle snapshot) with what autosolver has been applied
    - On victory, animate to zoom out fully (how to do that)?
    - AnimatedPanZoomListener seems a bit clunky at the start. Faster hook?
  - General issues:
    - Need better face coloring visualization (or ways to find those "loops")
      - "Connected component" visualization? (e.g. all faces that are connected by a black/red)
        - If we stroke/fill this, we'd need to write that "tracing" of outside boundaries (that we'll use for hex)
      - "Seam" visualization? (e.g. lines between connected components)
  - Annotated actions
    - Possibly with the "difficulty" if auto-solve involved
  - Annotated errors
    - Subtype InvalidStateError - for simple ones especially, we can visually report on the issue
  - Autosolver JUST to check for simple errors (or in general)
    - [NEEDS] annotated errors 
    - e.g. toss the action of the SimpleFaceSolver/SimpleVertexSolver, just look for errors thrown
  - Hex "square" line cap makes things confusing, looks off-centered in hexagonal
  - FILE SIZE improvements:
    - If we cut scanURL (and iframe-load it to compute)... we go from gzip 4MB => 0.67MB
    - If we attempt to do a dynamic import (in NewNode):
          TypeError [PLUGIN_ERROR]: [vite:load-fallback] Could not load vite/preload-helper (imported by src/view/NewNode.ts): The argument 'path' must be a string or Uint8Array without null bytes. Received '\x00vite/preload-helper'
              at open (node:internal/fs/promises:586:10)
              at Object.readFile (node:internal/fs/promises:1037:20)
              at Object.load (file:///Users/jon/phet/git/slither/node_modules/vite/dist/node/chunks/dep-jDlpJiMN.js:66605:43)
              at async PluginDriver.hookFirstAndGetPlugin (file:///Users/jon/phet/git/slither/node_modules/rollup/dist/es/shared/node-entry.js:19479:28)
              at async file:///Users/jon/phet/git/slither/node_modules/rollup/dist/es/shared/node-entry.js:18650:33
              at async Queue.work (file:///Users/jon/phet/git/slither/node_modules/rollup/dist/es/shared/node-entry.js:19689:32)
  - Exterior UI (improved "new" popup, etc.)
    - We have the puzzle/solver Node
    - TRANSITION swipe animation, like game screens
    - Have tutorial, rules, options, etc.? Better scaffolding
  - AutoSolve rule presets - WHAT IS RELAXING / fun
    - "rules that only set red edges" might be relaxing
  - "Error on startup" detection
    - clear puzzleString first? if not set, clear localStorage?
    - set a flag in localStorage noting that it was cleared (so we can display a message?)
    - force the reload
  - Create "helper" methods for things with interfaces. (Can we add implementation to an interface?)
    - We want to give anything implementing the interfaces multiple helper methods... is that just abstract classes? 
    - TODO: I need to read up more on TypeScript
    - Just... use top level methods for now...?
      - HEY! Put each interface into a file, and then PUT FUNCTIONS THAT USE IT in the same file 
  - FIX puzzle loading, especially on phone (or get some other way of getting puzzles in)
    - Soon we'll be able to... generate puzzles? Get backtracker?
  - Simple Region based edges, OR prefer the raw edges (uncolored)? 
  - Smooth animations between things ... instead of "New", have a main menu?
  - Try VSCode
  - Mobile vs Desktop
    - Settings presets for each?
    - OR detect fingers/mouse and apply different rules for them?
    - BASICALLY just try out both a bunch (phone, touch-pad, mouse)
  - Accessibility
    - Fix up modal a11y, see how it works/looks
    - Let's get accessibility highlights a bit more refined-acceptable looking? 
    - Keyboard
      - Keyboard + Accessibility is first-class? (Could be fast for input on a computer) 
    - Allow selecting a square. Hear its number/sides, manipulate its sides ("space blank, lines on top and left, blank on bottom, x on right")
    - Allow going through a vertical check list box easily?
  - Potentially "animate in" auto-solved things, and clicks don't do anything during the fade in(!)
    - THIS IS ANNOYING ON MOBILE 
    - Or at least have a delay
  - Background behind navbar? (so navbar can have its own transparency?) hmmm
  - Annotated solver actions (to show what happens next) <- omg, what if we animate this? (flash what it sees, then what it does)
    - PUZZLE SOLVING VIDEOS or ANIMATIONS would be really neat!!! - could it put these on YouTube (with text/annotations), people could pause if they don't see/understand?
  - Check when solved - we only have one chain + all numbers satisfied
  - NUMBER ONLY rules (at the start)
    - Most of these would be pattern based. Maybe get pattern solver working first (it's noted above)
  - FAST FAST solver setup for computer backtracking (to determine if a puzzle is valid/unique, useful for scanner)
  - Show puzzle loading progress (and speed it up), mobile is annoyed. Do error detection
  - USE ALPENGLOW??? --- and specify font (we can embed the glyphs no?)
  - Try hex boards (or other shapes) -- actually, this will be useful for testing any "general" solvers, and making sure I've abstracted enough logic?
  - https://vite-pwa-org.netlify.app/ - PWA this so I can have it on my phone
    - https://github.com/richardtallent/vite-plugin-singlefile
  - Audio for actions
    - Might help cue on unintended actions
  - Localization / Internationalization
  - Difficulty estimation of puzzles:
    - Should all solvers give the difficulty?
    - Should all solvers be designed to work so they can be re-run without applying the action? YES, right?
    - Should all solve actions - have a "difficulty" rating?
    - Single-level backtrack for "what state can we combine" - if we can't find explicit rules?
  - Allow puzzle export
    - navigator.share(), can share images, https://stackoverflow.com/questions/68362603/share-image-via-social-media-from-pwa
    - String formats?
  - [DEFER] Save full PuzzleModel state (serialize actions and stack)
  - Puzzle editor
    - HOW does this integrate with the current board generator? 
    - Delete or manipulate faces from the board (e.g. from board generation)
    - Set values of faces manually
    - Feature to "add in other numbers" based on solver?
  - Board Generation:
    - Consider NumberSpinner instead of NumberControl? 
    - Import from SVG string? 
    - Hide some boards behind "show experimental"? 
    - Add in rotation for tilings/others? integer prop, 0-360 (because people are used to degrees?)
    - Tick marks on sliders?
    - Consistent preview stroke size (prescale?)
    - Instead of our current "radius cutoff", perhaps find a central vertex or face, and measure "adjacency distance" from it!!!
      - Either "within grid", "by centermost vertex", "by centermost face"
    - Allow the user to "save" boards (and name them - see text entry?)
  - Lazy initialization of all of the tiling data?
    - Each tiling can be instantiated
    - Each tiling can just be used to either (a) create all of its polygons, or (b) create polygons to fill bounds
  - Demo videos?:
    - topological view
    - face coloring
  - Improved name:
    - Looperoo?

- Write up:
  - Force-directed graph layout (techniques for planarity?)
  - Force-directed color layout (region and face)

- Rule generation / display
  - SAT solver tweaked for the exact constraints(!!!!) 
  - Show a full explainer (with immutable views of puzzles)
    - !!! Not popular enough to NOT have an explainer. 
    - Link off to full databases of patterns 
  - How can we detect/visualize highlander rules?
  - Show rules with a nice before/after(!) - have the ability to generate that into a Scenery node. Use Display in write-up
  - For many rules, showing the "candiate test-add", "consequences", "thus we can assume this" as the three stages is nice.
  - Grab rules from my discord paster
  - Show the "next rule" that can be applied (and why) - consider TAnnotatedAction?
  - In Rule Description (auto-solver) describe the rule there with images? Possibly animate it?

- Read
  - https://link.springer.com/chapter/10.1007/978-3-030-34339-2_8 
  - check r/slitherlink for more cases that were explained well!
  - Look up things under https://puzzling.stackexchange.com/search?q=slitherlink

- Solving
  - General:
    - Can we assume uniqueness for the solver specifically? Adjusts techniques we can use
    - If we run through a solver WITHOUT applying changes, we get a list of what it can figure out without going deeper.
  - [from elsehwere, cleanup] Data:
    - SimplifiedVertexState: note if it is incident/spiked --- how does this extend to other grid types (don't try?)?
    - VertexState: (can pretend to be SimplifiedVertexState)
      - Allow empty or every combination of 2 edges
    - Jordan curve around face (possibilities and rules)
    - SAT formats? CNF for edges?
  - Patterns:
    - "Pattern" SOLVER!!! (inspect numbers, identify possible pattern locations that can individually get checked)
      - Each pattern needs to specify the required topology/structure for the area (what is important)
      - FOR EACH topology, many cases we DO NOT CARE how many other edges a vertex supports, as long as they are red.
      - RED EDGES essentially CHANGES the topology
        - Make rules that can be applied to ANY cases 
      - Going off the side of the board is "all x" - Use a way of pattern matching those
    - Pattern (GridPattern?) -- less general than "solver"
      - check( spot: Spot, reversed: bool ): bool - whether it matches and can be applied
        - apply( spot: Spot, reversed: bool ): Action[] - what to do
        - !!! data for the ability to explain the pattern to the user (in a specific case too?)
        - bounds: ???PatternBounds? <---- maybe don't have this?
        - NOTE: can be "extended" patterns, e.g. like extended-2-spike (doesn't need to be fixed and have bounds?)
          - e.g. while vertexstate handles spike 3-2-2-3, we can have a pattern that handles this with just EdgeState
        - NOTE: can be "mechanical/recorded" patterns too (e.g. have a database of these)
        - NOTE: PATTERNS CAN APPLY ACROSS TOPOLOGIES IN MANY CASES
  - FACE (OPTION) STATES
    - How the edges can be arranged around a face - constrained by numbers, but also works for blank faces
    - TODO: rename curreny FaceState to FaceValue, so this can be FaceState?
  - FACE COLORS, and the advanced "how they meet" rules
    - NOTE: determine if there is "internal" things in any "almost loop"
      - Detect case where there is a loop that is almost closed, except it has a single edge OR corner (so we can't enter it)
    - LOOK UP color patterns for vertex or square-loop state. Remember, a spiked 2 will continue colors past it (even though we don't know what edges will be set)
    - OMG OMG look up how we can interact with vertex/edge/face/etc. state with patterns... could discover cool coloring patterns(!)
  - Fundamentally async/await? (e.g. delayed auto-solver in general?) - Or should we synchronous it for simple ones?
    - async/await backtracker, especially between solver bits.
    - NOT IN GENERAL
  - Face values are fairly constant, can inspect up front to determine "WHERE" we can apply certain patterns.
  - "Finder" can find patterns, or use patterns/solvers/combination to solve everything (or to a point).
    - e.g. anything ending in backtrack will "work"
  - Highlander rules (how to we detect more?)
  - Note that if we have a closed loop, path crossings are even, so any adjustment to the loop should also have an even delta
  - OMG OMG solve that "crossing a spiked two" maintains the chain/line
    - SO COLOR IT in the UI! What other cases can we detect that will maintain the link?
  - Refer to things with Jordan curves
    - Different from "enclosing curve"? - how to handle going "corner through vertices" for the "needs 2+" in
      - Can JUST use FaceValue (basic), but also EdgeState (normal) or VertexState (advanced!) or coloring (yes!)
        - For "enclosing", we need to make sure there is content inside and outside. Numbers or edges mean there will be edges.
          - Numbers fully outside, or... hmm 
    - "How to solve the Jordan curve walked a turn around white. Only one can get out through vertices" - think of curves that turn at verties.
  - Jordan curve "corners" that only permit one through (and a closed area that needs 2+)
  - Do have a solver have pseudo-edges and pseudo-faces (marked "outside") around the border?
  - Show the user (for a given puzzle) how much of certain techniques it takes. Estimate difficulty
  - Boolean edge pairs!!! (many cases where we know something will be one of two, e.g. the double-3 pattern) - interacts in fun ways
    - Actually, can factor out to "boolean" sets of edges (black OR red)
  - KwonTomLoop threads for ideas:
    - Main patterns: https://kwontomloop.com/forum.php?a=topic&topic_id=100 
    - Especially this one: https://kwontomloop.com/forum.php?a=topic&topic_id=404
    - https://kwontomloop.com/forum.php?a=topic&topic_id=464
    - https://kwontomloop.com/forum.php?a=topic&topic_id=94
    - https://kwontomloop.com/forum.php?a=topic&topic_id=424
    - https://kwontomloop.com/forum.php?a=topic&topic_id=404
    - https://kwontomloop.com/forum.php?a=topic&topic_id=419
    - https://kwontomloop.com/forum.php?a=topic&topic_id=400
    - https://kwontomloop.com/forum.php?a=topic&topic_id=358
    - https://kwontomloop.com/forum.php?a=topic&topic_id=308

- Testing
  - Use seedRandom setup so we can get reproducibility.

- Performance
  - Web workers(!) - particularly for minisat
  - Unassert: https://github.com/unassert-js/rollup-plugin-unassert
  - Avoid animating anything outside-of-viewport?
  - Puzzles are SLOW on mobile, and scrolling is ugly. Perhaps we could use a separate Scenery display for the puzzle, and a separate one for the UI?
  - Assertion removal with unassert isn't... applying much so far. TODO check
    - unassert isn't stripping our assertions!
    - See https://github.com/unassert-js/rollup-plugin-unassert and https://github.com/unassert-js/unassert
  - Bit-pack states (especially for square edge/face/etc.) - have a linear array based on logicalCoordinates.
  - Not great performance on: 80x50 ..2223.1...3.2..31..1.0.2.2..2..22..1.32...211.3..23.22232..2.3..2..11..2.2212....1322.2.1..00....1...2..31.11.12..1.1.1.12...0..322.1..1..210..22.2..2.22.1.0..1.11..10.1.....3.22.3.01...22..22111..3..221...3....3..2...11.1.3.3...12.120...2.3.00....2.3..11.1..2.0.21..2..21.0..1.2.2.1.3.110....2.223.32..1...2...1...1311..1..1...33.....3..3..1..2...110..2.0.2.2..121......222212.1.....3..3.0.3.1..2...22..1.1.2.1.1111.1.1.3112........20133.2..3...2.11.311.2....12.....0...02.1.22.1.101....2.2.3.332..1...13..2..32.3....12.0.12.012.131...201..102..321...2.2.0.11..21212.2....1....2123..1.3..0..2.1...1...1....2.....01.2...1....11....3.13.2.1.3...1..0..11...2..2.22.3..2.32..3.1..1.0223.22.22..3.3..1..211.3....3....32....31..0...1.2111.13123.......223..2..21...23....02..1...11..1.012..1.1.0.......1...1..10222.....3.3..2.2..3.2.122.2..1..0.3.213...22.......120...2221.1.321..3..21..11...22.2..0.111.3122.2...2.....211...1.....31..2.223......21.........131.1.2021..112.3..12..1..3.2.22...22..201...0.2........0.2.12..0.3.23.2.111.3.10...12...12.2131..1....3..2..21..212..2...12.2....3.133.2.1112.........211.....1.1..31..1..1.3..22.201..111.2.2..1.1.0..3..0.....11..2..2...2.1.22.23..2....10..1.21.11.......2..3.3...13.2322...31..........1.0.32.2....211..0..21.2.10.2..1..0..2...1..31..2.122..22...3...223.12..31...33...2..1.2..0.20.1.3..1.......0.12.....02...222.23.3.122.2.....23.20...20...1..0..101.32......21..0.03.22130.00..32.31...3..0...11.1..0.2.123.2..13.1....1.20..1.3...21..1.33.32...1...2.1.3...31...22231.131.2...1232..211..223222..22..3.01..1.0..1.....3....1.0.3..2121.21..12..10.2....2.1.132..12..1..2........3.212.....01.1..2..22..1113.1.122..1...21...3.1..121112.3...1..22.2..1323202.2.2.1..13..2...23...2132.32.....2.1.2.2.21.1.12..01.21....1..12......013...20..1212..0..211...3..001.112...11...2.13221..2.23..13..3.1111.1.22.132..........1.22..11...12...1.2..1.01..131.1...21.2...12.2...........12...0.231...2.20.2.1.1..311..2.3..22201.12233..33..1..212.10.12.3.3....3.....21.2....21..2022..3.0..2..0..2.2.2.0.222.1....1..1...1.1.1.........11..0122.2111..02.3..0....1..3.1....2..23...3...2..11.2.112232.2.1..21.232.22.1..11....122.2..21.3.2.2.11121...21.0..1.11.2..13..22.2.1......210131...22.1.10....3.32.2.3210.......2..31.....213.1..12...131...02.12...122.........3.22.1.1..1232.1..1.0.2112..2...32..0.3.2..2.1..1..03..11..32.2..21.....0..11.3.222..1.1112.1.2.21...1.1.2..000...3.2.1....2...32..3.1.....2.2.1.2.3.21210..31...133.2.22...1.2.2.31....1.......1.122...01.1.223..2..1.3.3.220...2.0..221..1..322.12221...2.111.23.2...32.13..2..20..2.10.3.1.......20122..2.3...3..1...20.0...1....1..1.112.2..1.02..2..213..2..2.2.2.0....12..3......22.......31..1...2..1132220..2.12.2...21...3..1212...201...1221...23.3...133..0....2.11.1..3.0.222221.........1.22...22323..10.11...221111.2..1...1.13.211.0..1.1212.231........1.1..2.12.221..2.3.1.2..1.0....1222......2...11.3.......1...232.....2..2.10.0..3.2..21.013.3.3.212...3.1.2..022.2....2.3..0...31..0111...10..11.1.2.21..22..2....1..2.32.1.......1.1...2.13.......22.22...2.1..1.0..1.10.0...1.1102..201111213.12..322.2.2.....2.1..2.3.1...11.32.1...2..1.1.3.0..0.....1.22213...22....2....20...2..3.1.2..1.31310.0.2..1.1......23.223..1..3.12..213.3..1.3...1.0..1....3..2...12.21.13..2.....2....1...30.3.31......1.220.3.2..1.....13..22...0....13......1.21.2..0..23..311..20..33.1...1..312.3.32..2..1.22...3.23222...1.02.20.2....0.21..1.31..0.2..3.12.2.1.1...2.0.1.1..3....3..21....222.1....12112.......02.3..1.2..2213...1...0112..2..23.....1.3..13...011......22...0.2.1..3....112.3..3..1..3...1.2.121.01........2..1.1221....2..3.02.231130..223..2332....2013....10......3.2..22...0..112...2..11...21.1..1.1........2..10.1.3.3.....311.1.......101223...23....222.3..1...3.1.12...12..0...1.3.3...32..112......13..22..32.112..2.1..2.21.02111...2..222.3.0..112.0...33.12.0....1.....1...1323.2..13..2112.21.1222..221.11..23.132..3...3...1..2.........0.1..1.22.10..0..2...1.0....0..2...22.3.3.1.311.2..1..2.2212..1..1..1332223.0.....21..0...3.12
- 
- Maintainability
  - Prettier
  - At a certain point, cut features and clean clean 
  - Separate out structure.ts into a structure directory
  - Make clean! Document things!
  - Add copyright statement to files at some point

- Scaffolding
  - "Each number needs to have that many edges/lines around it, and no more"
  - "Single loop, like a loop of string"
  - Use coloring and description like in https://ciechanow.ski/airfoil/
  - See https://meganesulli.com/blog/paper-mario-tutorial/
