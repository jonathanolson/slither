
- Reorganize TODOs

- Try out on phone?
  - Seems to load!! 

- Shapes
  - Get topological handling for any shape, but specialize for 4x4 grid
  - Hex! And other planar tilings
  - NO sphere, easier for the graphics/model to not make that generalization right now

- UI
  - Phone interface works nicely (iOS/Android) 
  - Keyboard is first-class? (Could be fast for input on a computer)
  - Display
    - Vertex coloring (e.g. spikes/incident, but also "all of the cases")
    - Loop (around square parity), but also maybe a "loop tool" where if you draw it, it will count automatically.
    - Area coloring (with specific known-inside or known-outside coloring, but also color other multiple-square areas)
      - blue/yellow (from the path tracing demo) for inside/outside default? 
    - Line coloring (different color for each connected line), helps visualizing endpoints
      - Include culori(!) 
    - Lines go flush to (and include) the vertex dots
      - If RED on all 4 of a vertex, perhaps we can remove vertex dot?
    - Optional BLACK: solid line WHITE: dashed line, RED: no line
      - IF we have this, potentially remove the vertices appearance if they won't have lines through them?
      - DASHES seem like a good appearance for hex
      - !!! This looks really nice
    - Optional: themes(!) control how things are displayed. Not too hard to do. Neon on black is neat
      - For other shapes, displaying the "potential" line looks really helpful
      - Potentially use localStorage for themes?
    - Optional: red x's look ... not great on triangular potentially?
    - SLICK animation(!)
      - Can we make it more intuitive by having the line animate?
      - Option for no animation, or animation speed
    - Themes INCLUDE the animation(!)
      - Show animated "previews/thumbnails" in theme picker
    - Possibly multiple views (one coloring, one vertex?)
  - Themes
    - Grid will have different options (since edges can be fully implicit), hex or more complicated might need to show
  - Allow puzzle export
    - Image
    - JSON?
    - String
    - URL
  - Interaction
    - IDEALLY we should have a good way for "touch" to input Xs. Maybe a "shift"-equivalent button? 
      - An "inverse" or "X" sticky button at the top? 
    - Programmatically create the mouse/touch areas for the lines (noting vertex clicks for interactivity or dead zone)
      - Use offset curves or "what is closest"? 
    - Allow finger drag to put down multiple lines? (can we reverse back through a line to undo parts?) 
    - Vertex interaction (note incident or spike? - or any of possible vertex states?) 
    - Chess-like history, with branching?
    - "Safety net" - Mistake detection (but only after you've "stabilized"?)
      - Slightly delayed "error" popup, option to turn off 
      - Button to rewind + show error
    - Auto-solver for various sets of "solvers" (basic level is auto-X or auto-line)
      - I'm used auto-solving only doing x's (face and vertex checks)
  - Accessibility
    - Allow selecting a square. Hear its number/sides, manipulate its sides ("space blank, lines on top and left, blank on bottom, x on right") 

- TODO: combine this with the section below
- Solving
  - Regions:
    - PROVE things, this is my... intuition. 
    - Region (strict): 
      - Two vertices (distinct and unordered) -- can relax "distinct", degenerate region with duplicated vertex and no edges works
      - Edge set
      - "There will be one (and only one) strongly-connecting chain between the vertices through edges in the edge set"
      - "The final opposite part of the loop goes through none of the edge set"
      - (it will not contain the entire loop)
    - Completed: if its edge set is only black (no white)
    - Final edges: set of edges in the edge set that connect to one of the vertices
    - Dual (!): Same vertices but inverted edges (all other white/black edges not included) is a region
    - Intersections are a region IF intersection of final edges is non-empty
    - Single final edge (for a vertex) => it must be black
      - Removing that edge (and moving the vertex) creates a valid region (if it wasn't the only edge? - see degenerate region) 
    - Subregion: has a subset of edges
    - Disjoint: no edges in common
    - Ordering: Ordered list of disjoint non-degenerate subregions, such that subregion vertices match up (e.g. subregions AB, BC, CD -- for a region AD)
    - 
    - If a region AZ has a subregion AB, then ... clearly there exists a subregion BZ, but can we deduce anything about its edges?
      - No guarantee on edges? (unless it is completed)
    - 
    - (!!) If a region has ANY edges that are "graph bridges" (bridges) between the two (region) vertices, then it is black.
      - This is a generalization of the "single final edge (for a vertex)" rule 
    - 
    - Disjoint subregions will eventually be ordered
    - 
    - Any Jordan "cut" (that has two Jordan paths/loops) that crosses precisely 2 edges/vertices (or equivalent) creates a pair of regions
      - A "constriction" 
    - 
    - How does "joining" regions work?
      - (AB) + (BC) = (AC) iff A != C  <--- but best for edge sets if we keep these separated. how can we decompose regions?
      - (AB) + (BC) = full loop (not a region)
    - 
    - Degenerate region: does a single vertex with no edges count?
    - Unit region: two vertices with a single edge (it is black)
    - Spike2 region: two vertices across a 2
    - 
    - Vertex pair:
      - Abstraction does NOT require they are endpoints
      - They are not ordered
    - Edge sets:
      - Can exclude red edges
    - Two regions with the same vertex pair:
      - Final state will be two completed regions
      - ... does intersection work?
  - FACE (OPTION) STATES
    - How the edges can be arranged around a face - constrained by numbers, but also works for blank faces
    - TODO: rename curreny FaceState to FaceValue, so this can be FaceState?
  - EDGE COLORS / Chains
    - EdgeColor:
      - Both endpoint vertices (only two)
      - all edges in the color (lookup)
      - Chains: Chain[]: --- all connected
        - both endpoint vertices (only two)
        - all edges in the chain (lookup, but ideally also in order, for fast visual display in UI)
    - Each delta will likely "merge" or "split" chains/colors
      - Yes, we need to think of black => white/red. 
    - Is it... possible to insert something in-between two chains? (not really if we only do spiked-2s, but otherwise.... yes)
      - for now, just handle spiked 2 case? hmmm what are other cases?  
    - NOTE: color vs chain (think of chain as connected, and color as for cases where we can guarantee connection) 
    - 
    - HEY we should have a separate option for "auto-solve things that join chains" (since that might give things away?)
    - 
    - Store chains (list of current edges + end vertices) WAIT WAI TWAIT
    - They can WALK around spiked 2s, so these DO NOT need to be connected(!)
  - FACE COLORS, and the advanced "how they meet" rules
    - NOTE: determine if there is "internal" things in any "almost loop"
      - Detect case where there is a loop that is almost closed, except it has a single edge OR corner (so we can't enter it)
    - Create a pointer system (from face-color to face-color?) when things are joined, so we can do quick look-ups?
      - Eventually ends up inside/outside?
    - LOOK UP color patterns for vertex or square-loop state. Remember, a spiked 2 will continue colors past it (even though we don't know what edges will be set)
    - OMG OMG look up how we can interact with vertex/edge/face/etc. state with patterns... could discover cool coloring patterns(!)
  - Fundamentally async/await? (e.g. delayed auto-solver in general?) - Or should we synchronous it for simple ones?
    - async/await backtracker, especially between solver bits.
    - NOT IN GENERAL
  - If we run through a solver WITHOUT applying changes, we get a list of what it can figure out without going deeper.
  - Face values are fairly constant, can inspect up front to determine "WHERE" we can apply certain patterns.
  - Determine what data types each solver needs (most basic is EdgeState).
  - Backtrack:
    - Generalize for any "binary toggle" that is feasible. "Edge", "Color", or vertex state might make sense. Maybe "connection" too?
      - For instance, if an area connects 
    - Take a state, pick a white edge, and solve both the red and black case for the edge (could extend to other things)
      - If one fails due to invalid "state", the other is correct
      - If not, optionally look at OTHER state that is the SAME in both versions
        - (basically, look at the changed state for each case, and see if there is overlap) 
    - Could... do other things than toggling an edge. Looking at combinations of edges for faces or vertices. Vertex state
      - OOO or coloring? 
    - Look for the most "fruitful" / changing edges/changes
    - Don’t overfocus on backtrack performance. Don’t tune algo much. It is NP complete. 
      - Focus on fast solutions to human solvable puzzles. Focus on improving “pattern base” to catch things that backtrackers would
    - With backtracking, can apply “faster” solvers in both branches before “slower” ones. Maybe bad for memory, good for early exit?
      - Does this mean we can report the "difficulty" of the next dirty solver? 
  - Pattern solving (GENERALIZE, see below in implementation)
  - "Finder" can find patterns, or use patterns/solvers/combination to solve everything (or to a point).
    - e.g. anything ending in backtrack will "work"
  - Can we write... a RAW solver? To double-check?
  - Highlander rules (how to we detect more?)
  - Note that if we have a closed loop, path crossings are even, so any adjustment to the loop should also have an even delta
  - OMG OMG solve that "crossing a spiked two" maintains the chain/line
    - SO COLOR IT in the UI! What other cases can we detect that will maintain the link?
  - Ensure I have everything ported from my Scala code regards to solvers, e.g. "MediumFaceColorSolver?"
  - Refer to things with Jordan curves
    - Different from "enclosing curve"? - how to handle going "corner through vertices" for the "needs 2+" in
      - Can JUST use FaceValue (basic), but also EdgeState (normal) or VertexState (advanced!) or coloring (yes!)
        - For "enclosing", we need to make sure there is content inside and outside. Numbers or edges mean there will be edges.
          - Numbers fully outside, or... hmm 
    - "How to solve the Jordan curve walked a turn around white. Only one can get out through vertices" - think of curves that turn at verties.
  - Jordan curve "corners" that only permit one through (and a closed area that needs 2+)
  - Do have a solver have pseudo-edges and pseudo-faces (marked "outside") around the border?
  - Boolean SAT, https://www.comp.nus.edu.sg/~gregory/sat/, https://www.comp.nus.edu.sg/~gregory/sat/sat.js, https://jgalenson.github.io/research.js/demos/minisat.html
    - miniSAT looks... nice. Embrace the NP-completeness!
    - How... do we express the loop (only one) constraint? Not easy.
  - Show the user (for a given puzzle) how much of certain techniques it takes. Estimate difficulty
  - Boolean edge pairs!!! (many cases where we know something will be one of two, e.g. the double-3 pattern) - interacts in fun ways
    - Actually, can factor out to "boolean" sets of edges (black OR red)

- Performance
  - Bit-pack states (especially for square edge/face/etc.) - have a linear array based on logicalCoordinates.

- Puzzle generation
  - How to... rate? (Make it free obviously) - Give it numeric difficulties instead of just "easy/medium/hard"
  - A very fast puzzle generator would be needed for people (e.g. me) to play for free
  - Try to generate puzzles which have patterns that I should learn

- Generate/show rules
  - Show a full explainer (with immutable views of puzzles)
    - !!! Not popular enough to NOT have an explainer. 
    - Link off to full databases of patterns 
  - How can we detect/visualize highlander rules?
  - Show rules with a nice before/after(!) - have the ability to generate that into a Scenery node. Use Display in write-up
  - For many rules, showing the "candiate test-add", "consequences", "thus we can assume this" as the three stages is nice.
  - Grab rules from my discord paster

- Documentation
  - Make clean! 

- Read
  - https://link.springer.com/chapter/10.1007/978-3-030-34339-2_8 
  - check r/slitherlink for more cases that were explained well!

- Unassert: https://github.com/unassert-js/rollup-plugin-unassert

- Scan / Vision
  - Use the locations of text-detected numbers to "vote" on what contours to use as a container
    - Start at root. Check each child for how many it contains. Drill down until we have no child with more than the threshold.
    - This approach works well for "completed" or "invalid" puzzles (both of which we'll want to scan)
  - Unit tests
    - Much easier once we have a backtracker so that we can verify things are "uniquely solvable" and that the completion is correct. 
    - !!! Make us compatible with Puppeteer/Playwright, so we can batch-handle scanning/solving (for unit tests)
  - Test with Android, and handle dashed line approach
  - Detect on paper - perspective correction
    - See https://pyimagesearch.com/2020/08/10/opencv-sudoku-solver-and-ocr/ for helpful notes
  - Could use size of numbers to inform "scale" of things
  - Could use FFT for finding scale/grid
  - !!! Get Scenery working with embedding DOM components, like the file input
  - Note "draw interior of large region in background color" to filter out

- Puzzle editor
  - Particularly for things that didn't scan correctly.

- Current code TODOs
  - Config dialog (adjust properties, see if Dialog is usable with Popupable)
    - OMG, in the "SOLVER CONFIG"... describe the rule there? Possibly animate it?
  - LINE/CHAIN COLORING!!! <--- figure out model
    - Highlight the endpoints?
  - FACE COLORING!!!! <--- figure out model   + make solvers to solve the color state + ones that integrate color into other things
    - Have a "minimum number of colors before showing"? 
  - "Pattern" SOLVER!!! (inspect numbers, identify possible pattern locations that can individually get checked)
    - Each pattern needs to specify the required topology/structure for the area (what is important)
    - Going off the side of the board is "all x" - Use a way of pattern matching those
  - Solve (global) button
  - Annotated solver actions (to show what happens next) <- omg, what if we animate this? (flash what it sees, then what it does)
    - PUZZLE SOLVING VIDEOS or ANIMATIONS would be really neat!!! - could it put these on YouTube (with text/annotations), people could pause if they don't see/understand?
  - Check when solved - we only have one chain + all numbers satisfied
  - NUMBER ONLY rules (at the start) 
  - LIGHT/DARK color themes
  - FAST FAST solver setup for computer backtracking (to determine if a puzzle is valid/unique, useful for scanner)
  - Potentially "animate in" auto-solved things, and clicks don't do anything during the fade in(!)
    - Or at least have a delay 
  - Show puzzle loading progress (and speed it up), mobile is annoyed. Do error detection
  - Puzzles are SLOW on mobile, and scrolling is ugly. Perhaps we could use a separate Scenery display for the puzzle, and a separate one for the UI?
  - USE ALPENGLOW??? --- and specify font (we can embed the glyphs no?)
  - Separate out structure.ts into a structure directory
  - Add initial puzzles / puzzle states, so we don't have to image-load all the time
  - Try hex boards (or other shapes) -- actually, this will be useful for testing any "general" solvers, and making sure I've abstracted enough logic?

- Concepts
  - Solvers:
    - CLONE()!(!(!(!))) for each solver, so that we can "branch" it with state
    - Each solver listens to emitters it needs to. Sets dirty flag if it needs to run. Tracks what is "dirty" itself.
      - Especially for "complicated" ones, we can find that "first pattern solve" and exit, and STILL be dirty(!) 
      - Try to keep the "dirty" state as a stack, so it will handle recently-changed things first
    - Pattern solvers can still work
    - Potentially separate solvers into "human-readable this solver does one thing", and "machine solver, do a bunch of things efficiently" 
  - 
  - Store "actions" as a history.
  - "ethereal/fake/ghost" edges/faces/vertices for iterators?
    - Only for SquareSpot? 
  - Separate structure from data
    - "structure" is the topology, faces/vertices/edges/face values - doesn't change while solving
    - "data" is the edge-state, coloring, vertex-state, etc. - changes while solving
  - 
  - Structure
    - Grid
      - "parent" - a grid with fewer "things done" (... why not save that info elsewhere?) 
      - allowsInvalid?
      - "openBorders" - whether the "outside" is treated as white or red
  - Data:
    - Data should be... getters (so we can wrap with thin "if we change this" during backtracking)
      - Thin wrapper checks if our data OVERRIDES data on the "parent" 
    - EdgeState: black / white / red
    - SimplifiedVertexState: note if it is incident/spiked --- how does this extend to other grid types (don't try?)?
    - VertexState: (can pretend to be SimplifiedVertexState)
      - Allow empty or every combination of 2 edges
    - LineColor: (so we can connect things) --- note we handle this ideally for across-2s
    - FaceColor: Inside / Outside / ...others? <--- how do we handle collections of faces and coloring?
      - opposite: FaceColor --- display with opposite hues?
    - Jordan curve around face (possibilities and rules)
    - SAT formats
    - VertexState4:
      - bools: allowEmpty, allowHorizontal, allowVertical, allowNorthwest, allowNortheast, allowSouthwest, allowSoutheast
      - allows( state: EdgeState red/black, dir: CardinalDirection ): bool
      - with/without/booleanops/rotated/etc., see source in Scala
  - Utils:
    - Spot (like an iterator, that basically holds a vertex/half-edge and provides a lot)
      - PROVIDES ACCESS TO THE DATA/GRID?
      - "open" or "closed" boundaries (whether it returns data that is valid or not outside of boundaries).
      - nextLeft, nextRight, previousLeft, previousRight: Spot
    - Spot4 --- allows "ghost" operations, where we are not on a real vertex/edge/face, but it knows the coordinates
      - getEdge( dir: CardinalDirection ): Edge
      - getVertex( dir: CardinalDirection ): Vertex
      - getFace( dir: OrdinalDirection ): Face
      - N/S/E/W edge, vertex
      - NE/SE/SW/NW face
      - turnLeft, turnRight, turnBack, forward(), shiftLeft, shiftRight, shiftBack
  - Actions (Commands? - naming):
    - Should be "somewhat atomic"
    - global simplify( state: ..., actions: Action[] ): Action[]
      - Removes ones that don't apply an affect (after the previous ones, e.g. removes duplicates)
      - Can detect if there is no change
      - COMBINE actions of similar types into one composite (that can be scanned by solvers to determine dirtyness)
      - Note: actions on... different data types are... different/reorderable?
    - (have one for each... data type....?) 
    - ErrorAction (with a string or graphical representation?)
    - EdgeStateMove: { edge: Edge, state: EdgeState }
  - Solver
    - How to handle "invalid grid" / "invalid vertex state"? 
    - canAssumeUnique?
    - Ability to "split" computation into awaits, with sleep(0)s, so we can keep our UI thread responsive
      - Can we use... web workers? ---- WEB WORKERS!!!!!!!!!!!!!!!!
  - Pattern (GridPattern?) -- less general than "solver"
    - check( spot: Spot, reversed: bool ): bool - whether it matches and can be applied
    - apply( spot: Spot, reversed: bool ): Action[] - what to do
    - !!! data for the ability to explain the pattern to the user (in a specific case too?)
    - bounds: ???PatternBounds? <---- maybe don't have this?
    - shift( rowShift, colShift ): Pattern
    - flipHorizontal/flipVertical/rotate90/rotate180/rotate270: Pattern
    - Have types of patterns:
      - ( FaceValue + EdgeState )
      - ( FaceValue + EdgeState + SimplifiedVertexState )
      - ( FaceValue + EdgeState + VertexState )
      - ( FaceValue + EdgeState + LineColor )
      - ( FaceValue + EdgeState + FaceColor )
      - ( FaceValue + EdgeState + JordanState )
    - NOTE: can be "extended" patterns, e.g. like extended-2-spike (doesn't need to be fixed and have bounds?)
      - e.g. while vertexstate handles spike 3-2-2-3, we can have a pattern that handles this with just EdgeState
    - NOTE: can be "mechanical/recorded" patterns too (e.g. have a database of these)
    - NOTE: PATTERNS CAN APPLY ACROSS TOPOLOGIES IN MANY CASES
  - View
    - Coordinates 
      - Each vertex has view coordinates
      - Each face has a coordinate for its center (for display of the number)
  - Interaction
    - User interaction history
      - Auto-solve can then provide additional actions
        - E.g. if the user is toggling white/black/red on something they just toggled, we will:
          - UNDO auto-solve, apply their action, RE-DO auto-solve
      - Do we "combine" a white=>black=>red into a single action?
    - Board states (for the interruptable animation to go in-between)
    - Undo/redo (as a tree ideally)
      - Can show "candidates" explored, that can be clicked on?
      - Allow a "mark save point" (that can be jumped back to)
    - Have PatternErrors that we can display to show conflict
    - Have PatternExplainers that we can display to show what we can deduce next
    - Have a "hint" button
    - Have a "solve a single bit" button
  - Configuration
    - Save in localStorage 
  - Puzzle input:
    - Manual
    - AI interpet puzzle image(!!!!!!)
      - OpenVC: https://opencv.org/get-started/ 
    - Generated
    - !!!!!!!!!!!!!!! Allow sharing the puzzle with a URL!!!!!!
  - Immutable views
    - Would be great for an "explainer" page (this would be fun to write up)

- Implementation
  - Use seedRandom setup so we can get reproducibility.

- Be the lichess of slitherlink?

- Conceptual notes
  - Structure: vertices/edges/faces and how they connect
  - Board: a group of vertices/edges/faces with a structure
  - Data: mutable info about the structure (face value, edge state, vertex state, coloring, etc.)
  - Board = structure of vertices/edges/faces
  - Puzzle = board + FaceState
  - Delta = action + previous state